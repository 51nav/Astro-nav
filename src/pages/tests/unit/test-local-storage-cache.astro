---
/**
 * æœ¬åœ°å­˜å‚¨ç¼“å­˜æµ‹è¯•é¡µé¢
 * Week 3 - ä»»åŠ¡3.1éªŒè¯
 */

import { LocalStorageCache } from '../../../utils/LocalStorageCache';

// æµ‹è¯•ç»“æœæ¥å£
interface TestResult {
  name: string;
  success: boolean;
  duration: number;
  details: any;
  error?: string;
}

async function runTest(name: string, testFn: () => Promise<any>): Promise<TestResult> {
  const startTime = performance.now();
  try {
    const result = await testFn();
    return {
      name,
      success: true,
      duration: performance.now() - startTime,
      details: result
    };
  } catch (error) {
    return {
      name,
      success: false,
      duration: performance.now() - startTime,
      details: {},
      error: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
    };
  }
}

// åˆ›å»ºæµ‹è¯•ç¼“å­˜å®ä¾‹
const testCache = new LocalStorageCache({
  prefix: 'test_cache_',
  defaultTTL: 5 * 60 * 1000, // 5åˆ†é’Ÿ
  maxSize: 1024 * 1024, // 1MB
  maxItems: 50,
  enableCompression: true
});

// æ‰§è¡Œæµ‹è¯•
const testResults: TestResult[] = [
  // æµ‹è¯•1: ç¼“å­˜åˆå§‹åŒ–
  await runTest('ç¼“å­˜åˆå§‹åŒ–', async () => {
    const stats = testCache.getStats();
    
    return {
      initialized: true,
      totalItems: stats.totalItems,
      totalSize: stats.totalSize,
      hitRate: stats.hitRate,
      compressionEnabled: true
    };
  }),

  // æµ‹è¯•2: åŸºç¡€å­˜å–æ“ä½œ
  await runTest('åŸºç¡€å­˜å–æ“ä½œ', async () => {
    const testData = { name: 'test', value: 123, array: [1, 2, 3] };
    
    // è®¾ç½®æ•°æ®
    const setResult = await testCache.set('test-key', testData);
    
    // è·å–æ•°æ®
    const getData = await testCache.get('test-key');
    
    return {
      setSuccess: setResult,
      dataRetrieved: !!getData,
      dataMatches: JSON.stringify(getData) === JSON.stringify(testData),
      retrievedData: getData
    };
  }),

  // æµ‹è¯•3: æ•°æ®ç±»å‹æ”¯æŒ
  await runTest('æ•°æ®ç±»å‹æ”¯æŒ', async () => {
    const testCases = [
      { key: 'string', value: 'hello world' },
      { key: 'number', value: 42 },
      { key: 'boolean', value: true },
      { key: 'array', value: [1, 2, 3, 'test'] },
      { key: 'object', value: { nested: { data: 'value' } } },
      { key: 'null', value: null }
    ];
    
    const results = [];
    
    for (const testCase of testCases) {
      await testCache.set(testCase.key, testCase.value);
      const retrieved = await testCache.get(testCase.key);
      
      results.push({
        type: typeof testCase.value,
        key: testCase.key,
        original: testCase.value,
        retrieved,
        matches: JSON.stringify(retrieved) === JSON.stringify(testCase.value)
      });
    }
    
    return {
      testCases: results,
      allMatched: results.every(r => r.matches)
    };
  }),

  // æµ‹è¯•4: TTLè¿‡æœŸæœºåˆ¶
  await runTest('TTLè¿‡æœŸæœºåˆ¶', async () => {
    // è®¾ç½®çŸ­TTLçš„æ•°æ®
    await testCache.set('expire-test', 'will expire', 100); // 100ms
    
    // ç«‹å³è·å–
    const immediateGet = await testCache.get('expire-test');
    
    // ç­‰å¾…è¿‡æœŸ
    await new Promise(resolve => setTimeout(resolve, 150));
    
    // è¿‡æœŸåè·å–
    const expiredGet = await testCache.get('expire-test');
    
    return {
      immediateGet: !!immediateGet,
      expiredGet: !!expiredGet,
      ttlWorking: !!immediateGet && !expiredGet
    };
  }),

  // æµ‹è¯•5: æ•°æ®å‹ç¼©
  await runTest('æ•°æ®å‹ç¼©', async () => {
    // åˆ›å»ºå¤§æ•°æ®å¯¹è±¡
    const largeData = {
      description: 'A'.repeat(2000), // è¶…è¿‡å‹ç¼©é˜ˆå€¼
      numbers: Array.from({ length: 100 }, (_, i) => i),
      nested: {
        level1: {
          level2: {
            data: 'B'.repeat(1000)
          }
        }
      }
    };
    
    await testCache.set('large-data', largeData);
    const retrieved = await testCache.get('large-data');
    
    const stats = testCache.getStats();
    
    return {
      dataSize: JSON.stringify(largeData).length,
      compressionRatio: stats.compressionRatio,
      dataRetrieved: !!retrieved,
      dataMatches: JSON.stringify(retrieved) === JSON.stringify(largeData),
      compressionWorking: stats.compressionRatio > 0
    };
  }),

  // æµ‹è¯•6: ç¼“å­˜å¤§å°é™åˆ¶
  await runTest('ç¼“å­˜å¤§å°é™åˆ¶', async () => {
    const initialStats = testCache.getStats();
    
    // æ·»åŠ å¤šä¸ªé¡¹ç›®
    const addResults = [];
    for (let i = 0; i < 10; i++) {
      const result = await testCache.set(`limit-test-${i}`, `data-${i}`);
      addResults.push(result);
    }
    
    const finalStats = testCache.getStats();
    
    return {
      initialItems: initialStats.totalItems,
      finalItems: finalStats.totalItems,
      allAdded: addResults.every(r => r),
      itemsIncreased: finalStats.totalItems > initialStats.totalItems,
      sizeLimitWorking: finalStats.totalSize <= 1024 * 1024 // 1MBé™åˆ¶
    };
  }),

  // æµ‹è¯•7: ç¼“å­˜æ¸…ç†
  await runTest('ç¼“å­˜æ¸…ç†', async () => {
    // æ·»åŠ ä¸€äº›æµ‹è¯•æ•°æ®
    await testCache.set('cleanup-1', 'data1');
    await testCache.set('cleanup-2', 'data2');
    
    const beforeStats = testCache.getStats();
    
    // æ‰§è¡Œæ¸…ç†
    const cleanedCount = await testCache.cleanup();
    
    const afterStats = testCache.getStats();
    
    return {
      beforeItems: beforeStats.totalItems,
      afterItems: afterStats.totalItems,
      cleanedCount,
      cleanupWorking: cleanedCount >= 0
    };
  }),

  // æµ‹è¯•8: ç¼“å­˜ç»Ÿè®¡
  await runTest('ç¼“å­˜ç»Ÿè®¡', async () => {
    const stats = testCache.getStats();
    
    return {
      hasStats: !!stats,
      totalItems: stats.totalItems,
      totalSize: stats.totalSize,
      hitCount: stats.hitCount,
      missCount: stats.missCount,
      hitRate: stats.hitRate,
      averageSize: stats.averageSize,
      compressionRatio: stats.compressionRatio,
      statsComplete: typeof stats.totalItems === 'number' &&
                     typeof stats.hitRate === 'number'
    };
  }),

  // æµ‹è¯•9: æ“ä½œå†å²
  await runTest('æ“ä½œå†å²', async () => {
    // æ‰§è¡Œä¸€äº›æ“ä½œ
    await testCache.set('history-test', 'data');
    await testCache.get('history-test');
    await testCache.delete('history-test');
    
    const operations = testCache.getOperations();
    
    return {
      hasOperations: operations.length > 0,
      operationCount: operations.length,
      hasSetOperation: operations.some(op => op.type === 'set'),
      hasGetOperation: operations.some(op => op.type === 'get'),
      hasDeleteOperation: operations.some(op => op.type === 'delete'),
      operationsTracked: operations.length >= 3
    };
  }),

  // æµ‹è¯•10: ç¼“å­˜é”®ç®¡ç†
  await runTest('ç¼“å­˜é”®ç®¡ç†', async () => {
    // æ·»åŠ ä¸€äº›æµ‹è¯•æ•°æ®
    await testCache.set('key1', 'value1');
    await testCache.set('key2', 'value2');
    await testCache.set('key3', 'value3');
    
    const keys = testCache.keys();
    const hasKey1 = testCache.has('key1');
    const hasNonExistent = testCache.has('non-existent');
    const size = testCache.size();
    
    return {
      keys,
      keyCount: keys.length,
      hasKey1,
      hasNonExistent,
      size,
      keyManagementWorking: keys.length > 0 && hasKey1 && !hasNonExistent
    };
  }),

  // æµ‹è¯•11: é”™è¯¯å¤„ç†
  await runTest('é”™è¯¯å¤„ç†', async () => {
    // æµ‹è¯•æ— æ•ˆé”®
    const invalidGet = await testCache.get('');
    
    // æµ‹è¯•åˆ é™¤ä¸å­˜åœ¨çš„é”®
    const invalidDelete = await testCache.delete('non-existent-key');
    
    return {
      invalidGetHandled: invalidGet === null,
      invalidDeleteHandled: typeof invalidDelete === 'boolean',
      errorHandlingWorking: invalidGet === null && typeof invalidDelete === 'boolean'
    };
  }),

  // æµ‹è¯•12: å†…å­˜å’ŒlocalStorageåŒæ­¥
  await runTest('å†…å­˜å’ŒlocalStorageåŒæ­¥', async () => {
    const testKey = 'sync-test';
    const testValue = { sync: true, timestamp: Date.now() };
    
    // è®¾ç½®æ•°æ®
    await testCache.set(testKey, testValue);
    
    // æ£€æŸ¥localStorageä¸­æ˜¯å¦å­˜åœ¨
    const localStorageKey = `test_cache_${testKey}`;
    const localStorageData = localStorage.getItem(localStorageKey);
    
    // æ¸…é™¤å†…å­˜ç¼“å­˜ï¼Œæ¨¡æ‹Ÿé‡æ–°åŠ è½½
    const newCache = new LocalStorageCache({
      prefix: 'test_cache_',
      defaultTTL: 5 * 60 * 1000
    });
    
    // ä»æ–°å®ä¾‹è·å–æ•°æ®
    const retrievedFromNew = await newCache.get(testKey);
    
    return {
      dataInLocalStorage: !!localStorageData,
      retrievedFromNewInstance: !!retrievedFromNew,
      dataMatches: JSON.stringify(retrievedFromNew?.sync) === JSON.stringify(testValue.sync),
      syncWorking: !!localStorageData && !!retrievedFromNew
    };
  })
];

const successCount = testResults.filter(r => r.success).length;
const totalTests = testResults.length;
const successRate = (successCount / totalTests * 100).toFixed(1);

// è·å–æœ€ç»ˆç»Ÿè®¡
const finalStats = testCache.getStats();
const finalOperations = testCache.getOperations();
---

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æœ¬åœ°å­˜å‚¨ç¼“å­˜æµ‹è¯•</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    
    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
      margin-bottom: 30px;
      text-align: center;
    }
    
    .cache-dashboard {
      background: white;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin-bottom: 30px;
    }
    
    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    
    .dashboard-item {
      text-align: center;
      padding: 20px;
      border-radius: 8px;
      background: #f8fafc;
      border: 1px solid #e2e8f0;
    }
    
    .dashboard-item.good {
      background: #d1fae5;
      border-color: #10b981;
    }
    
    .dashboard-item.warning {
      background: #fef3c7;
      border-color: #f59e0b;
    }
    
    .dashboard-value {
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .dashboard-label {
      font-size: 12px;
      color: #6b7280;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .demo-section {
      background: white;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin-bottom: 30px;
    }
    
    .demo-controls {
      display: flex;
      gap: 10px;
      margin-top: 20px;
      flex-wrap: wrap;
    }
    
    .demo-controls button {
      padding: 10px 20px;
      border: 1px solid #d1d5db;
      background: white;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s ease;
    }
    
    .demo-controls button:hover {
      background: #f3f4f6;
      border-color: #9ca3af;
    }
    
    .demo-controls button.primary {
      background: #3b82f6;
      color: white;
      border-color: #3b82f6;
    }
    
    .summary {
      background: white;
      padding: 25px;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin-bottom: 30px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
    }
    
    .summary-item {
      text-align: center;
      padding: 20px;
      border-radius: 8px;
      background: #f8f9fa;
    }
    
    .summary-item.success {
      background: #d4edda;
      color: #155724;
    }
    
    .summary-item.warning {
      background: #fff3cd;
      color: #856404;
    }
    
    .summary-item .value {
      font-size: 32px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .summary-item .label {
      font-size: 14px;
      opacity: 0.8;
    }
    
    .test-results {
      display: grid;
      gap: 20px;
    }
    
    .test-card {
      background: white;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      overflow: hidden;
    }
    
    .test-header {
      padding: 20px;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .test-header.success {
      background: #d4edda;
      color: #155724;
    }
    
    .test-header.error {
      background: #f8d7da;
      color: #721c24;
    }
    
    .test-name {
      font-size: 18px;
      font-weight: 600;
    }
    
    .test-duration {
      font-size: 14px;
      opacity: 0.8;
    }
    
    .test-content {
      padding: 20px;
    }
    
    .test-details {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 15px;
      margin-top: 15px;
    }
    
    .test-details pre {
      margin: 0;
      font-size: 14px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    
    .error-message {
      background: #f8d7da;
      color: #721c24;
      padding: 15px;
      border-radius: 8px;
      margin-top: 15px;
      border-left: 4px solid #dc3545;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>ğŸ’¾ æœ¬åœ°å­˜å‚¨ç¼“å­˜æµ‹è¯•</h1>
    <div class="subtitle">Week 3 - ä»»åŠ¡3.1éªŒè¯ | æµ‹è¯•æ—¶é—´: {new Date().toLocaleString()}</div>
  </div>

  <!-- ç¼“å­˜ä»ªè¡¨æ¿ -->
  <div class="cache-dashboard">
    <h2>ğŸ“Š ç¼“å­˜çŠ¶æ€ä»ªè¡¨æ¿</h2>
    <div class="dashboard-grid">
      <div class={`dashboard-item ${finalStats.totalItems > 0 ? 'good' : ''}`}>
        <div class="dashboard-value">{finalStats.totalItems}</div>
        <div class="dashboard-label">ç¼“å­˜é¡¹æ•°</div>
      </div>
      <div class={`dashboard-item ${finalStats.totalSize > 0 ? 'good' : ''}`}>
        <div class="dashboard-value">{(finalStats.totalSize / 1024).toFixed(1)}KB</div>
        <div class="dashboard-label">ç¼“å­˜å¤§å°</div>
      </div>
      <div class={`dashboard-item ${finalStats.hitRate >= 50 ? 'good' : 'warning'}`}>
        <div class="dashboard-value">{finalStats.hitRate.toFixed(1)}%</div>
        <div class="dashboard-label">å‘½ä¸­ç‡</div>
      </div>
      <div class={`dashboard-item ${finalStats.compressionRatio > 0 ? 'good' : ''}`}>
        <div class="dashboard-value">{(finalStats.compressionRatio * 100).toFixed(1)}%</div>
        <div class="dashboard-label">å‹ç¼©ç‡</div>
      </div>
      <div class="dashboard-item good">
        <div class="dashboard-value">{finalOperations.length}</div>
        <div class="dashboard-label">æ“ä½œè®°å½•</div>
      </div>
    </div>
  </div>

  <!-- ç¼“å­˜æ“ä½œæ¼”ç¤º -->
  <div class="demo-section">
    <h2>ğŸ›ï¸ ç¼“å­˜æ“ä½œæ¼”ç¤º</h2>
    <p>æµ‹è¯•æœ¬åœ°å­˜å‚¨ç¼“å­˜çš„å„ç§åŠŸèƒ½</p>
    
    <div class="demo-controls">
      <button onclick="testBasicOperations()" class="primary">åŸºç¡€æ“ä½œæµ‹è¯•</button>
      <button onclick="testCompression()">å‹ç¼©æµ‹è¯•</button>
      <button onclick="testTTL()">TTLæµ‹è¯•</button>
      <button onclick="testCleanup()">æ¸…ç†æµ‹è¯•</button>
      <button onclick="showStats()">æ˜¾ç¤ºç»Ÿè®¡</button>
      <button onclick="clearAllCache()">æ¸…ç©ºç¼“å­˜</button>
    </div>
  </div>

  <!-- æµ‹è¯•ç»“æœ -->
  <div class="summary">
    <div class={`summary-item ${successRate === '100.0' ? 'success' : 'warning'}`}>
      <div class="value">{successRate}%</div>
      <div class="label">æµ‹è¯•é€šè¿‡ç‡</div>
    </div>
    <div class="summary-item">
      <div class="value">{successCount}</div>
      <div class="label">é€šè¿‡æµ‹è¯•</div>
    </div>
    <div class="summary-item">
      <div class="value">{totalTests - successCount}</div>
      <div class="label">å¤±è´¥æµ‹è¯•</div>
    </div>
    <div class="summary-item">
      <div class="value">{totalTests}</div>
      <div class="label">æ€»æµ‹è¯•æ•°</div>
    </div>
  </div>

  <div class="test-results">
    {testResults.map((result, index) => (
      <div class="test-card">
        <div class={`test-header ${result.success ? 'success' : 'error'}`}>
          <div class="test-name">
            <span>{result.success ? 'âœ…' : 'âŒ'}</span>
            æµ‹è¯• {index + 1}: {result.name}
          </div>
          <div class="test-duration">{result.duration.toFixed(2)}ms</div>
        </div>
        <div class="test-content">
          <div class="test-details">
            <strong>æµ‹è¯•è¯¦æƒ…:</strong>
            <pre>{JSON.stringify(result.details, null, 2)}</pre>
          </div>
          {result.error && (
            <div class="error-message">
              <strong>é”™è¯¯ä¿¡æ¯:</strong> {result.error}
            </div>
          )}
        </div>
      </div>
    ))}
  </div>

  <script define:vars={{ testResults, finalStats, finalOperations }}>
    console.log('ğŸ’¾ æœ¬åœ°å­˜å‚¨ç¼“å­˜æµ‹è¯•é¡µé¢å·²åŠ è½½');
    console.log('ğŸ“Š æµ‹è¯•ç»“æœ:', JSON.stringify(testResults, null, 2));
    console.log('ğŸ“Š ç¼“å­˜ç»Ÿè®¡:', JSON.stringify(finalStats, null, 2));
    console.log('ğŸ“Š æ“ä½œè®°å½•:', JSON.stringify(finalOperations, null, 2));

    // æ¼”ç¤ºå‡½æ•°
    function testBasicOperations() {
      console.log('ğŸ”„ æ‰§è¡ŒåŸºç¡€æ“ä½œæµ‹è¯•...');
    }

    function testCompression() {
      console.log('ğŸ—œï¸ æ‰§è¡Œå‹ç¼©æµ‹è¯•...');
    }

    function testTTL() {
      console.log('â° æ‰§è¡ŒTTLæµ‹è¯•...');
    }

    function testCleanup() {
      console.log('ğŸ—‘ï¸ æ‰§è¡Œæ¸…ç†æµ‹è¯•...');
    }

    function showStats() {
      console.log('ğŸ“Š æ˜¾ç¤ºç¼“å­˜ç»Ÿè®¡:', finalStats);
      alert(`ç¼“å­˜ç»Ÿè®¡:\né¡¹æ•°: ${finalStats.totalItems}\nå¤§å°: ${(finalStats.totalSize/1024).toFixed(1)}KB\nå‘½ä¸­ç‡: ${finalStats.hitRate.toFixed(1)}%`);
    }

    function clearAllCache() {
      if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰ç¼“å­˜å—ï¼Ÿ')) {
        console.log('ğŸ—‘ï¸ æ¸…ç©ºæ‰€æœ‰ç¼“å­˜...');
      }
    }

    // ä½¿å‡½æ•°å…¨å±€å¯ç”¨
    window.testBasicOperations = testBasicOperations;
    window.testCompression = testCompression;
    window.testTTL = testTTL;
    window.testCleanup = testCleanup;
    window.showStats = showStats;
    window.clearAllCache = clearAllCache;
  </script>
</body>
</html>
