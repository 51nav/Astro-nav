---
/**
 * æ€§èƒ½ç›‘æ§æµ‹è¯•é¡µé¢
 * Week 3 - ä»»åŠ¡2.2éªŒè¯
 */

import PerformanceMonitor from '../../../components/PerformanceMonitor.astro';
import { PerformanceMonitor as PerformanceMonitorClass } from '../../../utils/PerformanceMonitor';

// æµ‹è¯•ç»“æœæ¥å£
interface TestResult {
  name: string;
  success: boolean;
  duration: number;
  details: any;
  error?: string;
}

async function runTest(name: string, testFn: () => any): Promise<TestResult> {
  const startTime = performance.now();
  try {
    const result = testFn();
    return {
      name,
      success: true,
      duration: performance.now() - startTime,
      details: result
    };
  } catch (error) {
    return {
      name,
      success: false,
      duration: performance.now() - startTime,
      details: {},
      error: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
    };
  }
}

// åˆ›å»ºæ€§èƒ½ç›‘æ§å®ä¾‹
const performanceMonitor = new PerformanceMonitorClass();

// æ‰§è¡Œæµ‹è¯•
const testResults: TestResult[] = [
  // æµ‹è¯•1: æ€§èƒ½ç›‘æ§åˆå§‹åŒ–
  await runTest('æ€§èƒ½ç›‘æ§åˆå§‹åŒ–', () => {
    const metrics = performanceMonitor.getMetrics();
    return {
      initialized: true,
      hasMetrics: !!metrics,
      sessionStartTime: metrics.sessionStartTime > 0,
      initialScore: performanceMonitor.getPerformanceScore()
    };
  }),

  // æµ‹è¯•2: é…ç½®åŠ è½½æ—¶é—´è®°å½•
  await runTest('é…ç½®åŠ è½½æ—¶é—´è®°å½•', () => {
    const testLoadTime = 150;
    performanceMonitor.recordConfigLoadTime(testLoadTime);
    
    const metrics = performanceMonitor.getMetrics();
    
    return {
      recordedTime: testLoadTime,
      metricsTime: metrics.configLoadTime,
      recordingWorking: metrics.configLoadTime === testLoadTime
    };
  }),

  // æµ‹è¯•3: åˆ†ç±»åŠ è½½æ—¶é—´è®°å½•
  await runTest('åˆ†ç±»åŠ è½½æ—¶é—´è®°å½•', () => {
    const testTimes = [100, 120, 80, 150, 90];
    
    testTimes.forEach(time => {
      performanceMonitor.recordCategoryLoadTime(time);
    });
    
    const metrics = performanceMonitor.getMetrics();
    const expectedAvg = testTimes.reduce((sum, time) => sum + time, 0) / testTimes.length;
    
    return {
      testTimes,
      lastRecordedTime: metrics.categoryLoadTime,
      avgTime: metrics.avgCategoryLoadTime,
      expectedAvg,
      avgCalculationCorrect: Math.abs(metrics.avgCategoryLoadTime - expectedAvg) < 1
    };
  }),

  // æµ‹è¯•4: ç½‘ç»œè¯·æ±‚è®°å½•
  await runTest('ç½‘ç»œè¯·æ±‚è®°å½•', () => {
    const requests = [
      { time: 200, success: true },
      { time: 150, success: true },
      { time: 300, success: false },
      { time: 180, success: true },
      { time: 250, success: false }
    ];
    
    requests.forEach(req => {
      performanceMonitor.recordNetworkRequest(req.time, req.success);
    });
    
    const metrics = performanceMonitor.getMetrics();
    const expectedFailureRate = (2 / 5) * 100; // 2ä¸ªå¤±è´¥ï¼Œå…±5ä¸ªè¯·æ±‚
    
    return {
      totalRequests: metrics.networkRequestCount,
      failedRequests: metrics.failedRequestCount,
      failureRate: (metrics.failedRequestCount / metrics.networkRequestCount) * 100,
      expectedFailureRate,
      avgResponseTime: metrics.avgResponseTime,
      failureRateCorrect: Math.abs(((metrics.failedRequestCount / metrics.networkRequestCount) * 100) - expectedFailureRate) < 1
    };
  }),

  // æµ‹è¯•5: ç”¨æˆ·äº¤äº’è®°å½•
  await runTest('ç”¨æˆ·äº¤äº’è®°å½•', () => {
    const interactions = [50, 30, 80, 40, 60];
    
    interactions.forEach(time => {
      performanceMonitor.recordUserInteraction(time);
    });
    
    const metrics = performanceMonitor.getMetrics();
    const expectedAvg = interactions.reduce((sum, time) => sum + time, 0) / interactions.length;
    
    return {
      interactionCount: metrics.userInteractionCount,
      avgResponseTime: metrics.avgInteractionResponseTime,
      expectedAvg,
      avgCorrect: Math.abs(metrics.avgInteractionResponseTime - expectedAvg) < 1
    };
  }),

  // æµ‹è¯•6: ç¼“å­˜æŒ‡æ ‡æ›´æ–°
  await runTest('ç¼“å­˜æŒ‡æ ‡æ›´æ–°', () => {
    const cacheSize = 5;
    const maxCacheSize = 10;
    const hitRate = 85;
    
    performanceMonitor.updateCacheMetrics(cacheSize, maxCacheSize, hitRate);
    
    const metrics = performanceMonitor.getMetrics();
    
    return {
      cacheSize: metrics.cacheSize,
      maxCacheSize: metrics.maxCacheSize,
      hitRate: metrics.cacheHitRate,
      updateWorking: metrics.cacheSize === cacheSize && 
                     metrics.maxCacheSize === maxCacheSize && 
                     metrics.cacheHitRate === hitRate
    };
  }),

  // æµ‹è¯•7: é¢„åŠ è½½æŒ‡æ ‡æ›´æ–°
  await runTest('é¢„åŠ è½½æŒ‡æ ‡æ›´æ–°', () => {
    const preloadCount = 8;
    const successRate = 87.5;
    const cacheHitRate = 62.5;
    
    performanceMonitor.updatePreloadMetrics(preloadCount, successRate, cacheHitRate);
    
    const metrics = performanceMonitor.getMetrics();
    
    return {
      preloadCount: metrics.preloadCount,
      successRate: metrics.preloadSuccessRate,
      cacheHitRate: metrics.preloadCacheHitRate,
      updateWorking: metrics.preloadCount === preloadCount &&
                     metrics.preloadSuccessRate === successRate &&
                     metrics.preloadCacheHitRate === cacheHitRate
    };
  }),

  // æµ‹è¯•8: æ€§èƒ½è­¦å‘Šç”Ÿæˆ
  await runTest('æ€§èƒ½è­¦å‘Šç”Ÿæˆ', () => {
    // è§¦å‘ä¸€äº›è­¦å‘Šæ¡ä»¶
    performanceMonitor.recordConfigLoadTime(1500); // è¶…è¿‡é˜ˆå€¼
    performanceMonitor.recordCategoryLoadTime(2500); // è¶…è¿‡é˜ˆå€¼
    performanceMonitor.updateCacheMetrics(3, 10, 60); // ç¼“å­˜å‘½ä¸­ç‡ä½
    
    const alerts = performanceMonitor.getAlerts();
    
    return {
      alertCount: alerts.length,
      hasConfigAlert: alerts.some(alert => alert.metric === 'configLoadTime'),
      hasCategoryAlert: alerts.some(alert => alert.metric === 'categoryLoadTime'),
      hasCacheAlert: alerts.some(alert => alert.metric === 'cacheHitRate'),
      alertsWorking: alerts.length > 0
    };
  }),

  // æµ‹è¯•9: æ€§èƒ½å»ºè®®ç”Ÿæˆ
  await runTest('æ€§èƒ½å»ºè®®ç”Ÿæˆ', () => {
    const recommendations = performanceMonitor.getRecommendations();
    
    return {
      recommendationCount: recommendations.length,
      hasRecommendations: recommendations.length > 0,
      categories: [...new Set(recommendations.map(r => r.category))],
      actionableCount: recommendations.filter(r => r.actionable).length,
      recommendationsWorking: recommendations.length > 0
    };
  }),

  // æµ‹è¯•10: æ€§èƒ½è¯„åˆ†è®¡ç®—
  await runTest('æ€§èƒ½è¯„åˆ†è®¡ç®—', () => {
    // é‡ç½®ç›‘æ§å™¨ä»¥è·å¾—å¹²å‡€çš„è¯„åˆ†
    const cleanMonitor = new PerformanceMonitorClass();
    
    // è®¾ç½®è‰¯å¥½çš„æ€§èƒ½æŒ‡æ ‡
    cleanMonitor.recordConfigLoadTime(300);
    cleanMonitor.recordCategoryLoadTime(80);
    cleanMonitor.updateCacheMetrics(8, 10, 95);
    cleanMonitor.recordNetworkRequest(100, true);
    
    const goodScore = cleanMonitor.getPerformanceScore();
    
    // è®¾ç½®è¾ƒå·®çš„æ€§èƒ½æŒ‡æ ‡
    cleanMonitor.recordConfigLoadTime(1500);
    cleanMonitor.recordCategoryLoadTime(2500);
    cleanMonitor.updateCacheMetrics(2, 10, 40);
    
    const badScore = cleanMonitor.getPerformanceScore();
    
    return {
      goodScore,
      badScore,
      scoreRange: { min: 0, max: 100 },
      goodScoreValid: goodScore >= 80,
      badScoreValid: badScore <= 50,
      scoringWorking: goodScore > badScore
    };
  }),

  // æµ‹è¯•11: æ•°æ®å¯¼å‡ºåŠŸèƒ½
  await runTest('æ•°æ®å¯¼å‡ºåŠŸèƒ½', () => {
    const exportData = performanceMonitor.exportReport();
    
    let parsedData;
    try {
      parsedData = JSON.parse(exportData);
    } catch (error) {
      throw new Error('å¯¼å‡ºæ•°æ®ä¸æ˜¯æœ‰æ•ˆçš„JSONæ ¼å¼');
    }
    
    return {
      exportDataLength: exportData.length,
      hasMetrics: !!parsedData.metrics,
      hasAlerts: !!parsedData.alerts,
      hasRecommendations: !!parsedData.recommendations,
      hasScore: typeof parsedData.score === 'number',
      hasExportTime: !!parsedData.exportTime,
      exportWorking: exportData.length > 0 && !!parsedData.metrics
    };
  }),

  // æµ‹è¯•12: ç›‘æ§é‡ç½®åŠŸèƒ½
  await runTest('ç›‘æ§é‡ç½®åŠŸèƒ½', () => {
    const metricsBefore = performanceMonitor.getMetrics();
    const alertsBefore = performanceMonitor.getAlerts();
    
    performanceMonitor.reset();
    
    const metricsAfter = performanceMonitor.getMetrics();
    const alertsAfter = performanceMonitor.getAlerts();
    
    return {
      metricsBefore: {
        networkRequests: metricsBefore.networkRequestCount,
        userInteractions: metricsBefore.userInteractionCount
      },
      metricsAfter: {
        networkRequests: metricsAfter.networkRequestCount,
        userInteractions: metricsAfter.userInteractionCount
      },
      alertsBefore: alertsBefore.length,
      alertsAfter: alertsAfter.length,
      resetWorking: metricsAfter.networkRequestCount === 0 && 
                    metricsAfter.userInteractionCount === 0 &&
                    alertsAfter.length === 0
    };
  })
];

const successCount = testResults.filter(r => r.success).length;
const totalTests = testResults.length;
const successRate = (successCount / totalTests * 100).toFixed(1);
---

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ€§èƒ½ç›‘æ§æµ‹è¯•</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    
    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
      margin-bottom: 30px;
      text-align: center;
    }
    
    .demo-section {
      background: white;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin-bottom: 30px;
    }
    
    .demo-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    
    .demo-controls button {
      padding: 10px 20px;
      border: 1px solid #d1d5db;
      background: white;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s ease;
    }
    
    .demo-controls button:hover {
      background: #f3f4f6;
      border-color: #9ca3af;
    }
    
    .demo-controls button.primary {
      background: #3b82f6;
      color: white;
      border-color: #3b82f6;
    }
    
    .demo-controls button.primary:hover {
      background: #2563eb;
    }
    
    .summary {
      background: white;
      padding: 25px;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin-bottom: 30px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
    }
    
    .summary-item {
      text-align: center;
      padding: 20px;
      border-radius: 8px;
      background: #f8f9fa;
    }
    
    .summary-item.success {
      background: #d4edda;
      color: #155724;
    }
    
    .summary-item.warning {
      background: #fff3cd;
      color: #856404;
    }
    
    .summary-item .value {
      font-size: 32px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .summary-item .label {
      font-size: 14px;
      opacity: 0.8;
    }
    
    .test-results {
      display: grid;
      gap: 20px;
    }
    
    .test-card {
      background: white;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      overflow: hidden;
    }
    
    .test-header {
      padding: 20px;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .test-header.success {
      background: #d4edda;
      color: #155724;
    }
    
    .test-header.error {
      background: #f8d7da;
      color: #721c24;
    }
    
    .test-name {
      font-size: 18px;
      font-weight: 600;
    }
    
    .test-duration {
      font-size: 14px;
      opacity: 0.8;
    }
    
    .test-content {
      padding: 20px;
    }
    
    .test-details {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 15px;
      margin-top: 15px;
    }
    
    .test-details pre {
      margin: 0;
      font-size: 14px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    
    .error-message {
      background: #f8d7da;
      color: #721c24;
      padding: 15px;
      border-radius: 8px;
      margin-top: 15px;
      border-left: 4px solid #dc3545;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>ğŸ“Š æ€§èƒ½ç›‘æ§æµ‹è¯•</h1>
    <div class="subtitle">Week 3 - ä»»åŠ¡2.2éªŒè¯ | æµ‹è¯•æ—¶é—´: {new Date().toLocaleString()}</div>
  </div>

  <!-- æ€§èƒ½ç›‘æ§é¢æ¿æ¼”ç¤º -->
  <div class="demo-section">
    <h2>ğŸ›ï¸ æ€§èƒ½ç›‘æ§é¢æ¿æ¼”ç¤º</h2>
    <p>ä¸‹æ–¹çš„æ€§èƒ½ç›‘æ§é¢æ¿å±•ç¤ºäº†å®æ—¶æ€§èƒ½æ•°æ®ï¼Œå¯ä»¥æ‹–æ‹½ç§»åŠ¨ä½ç½®</p>
    
    <div class="demo-controls">
      <button onclick="simulateConfigLoad()" class="primary">æ¨¡æ‹Ÿé…ç½®åŠ è½½</button>
      <button onclick="simulateCategoryLoad()">æ¨¡æ‹Ÿåˆ†ç±»åŠ è½½</button>
      <button onclick="simulateNetworkRequest()">æ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚</button>
      <button onclick="simulateUserInteraction()">æ¨¡æ‹Ÿç”¨æˆ·äº¤äº’</button>
      <button onclick="simulateHighLoad()">æ¨¡æ‹Ÿé«˜è´Ÿè½½</button>
      <button onclick="resetMonitor()">é‡ç½®ç›‘æ§</button>
    </div>
  </div>

  <!-- æ€§èƒ½ç›‘æ§é¢æ¿ -->
  <PerformanceMonitor 
    visible={true}
    position="top-right"
    collapsible={true}
    defaultCollapsed={false}
    updateInterval={3000}
  />

  <!-- æµ‹è¯•ç»“æœ -->
  <div class="summary">
    <div class={`summary-item ${successRate === '100.0' ? 'success' : 'warning'}`}>
      <div class="value">{successRate}%</div>
      <div class="label">æµ‹è¯•é€šè¿‡ç‡</div>
    </div>
    <div class="summary-item">
      <div class="value">{successCount}</div>
      <div class="label">é€šè¿‡æµ‹è¯•</div>
    </div>
    <div class="summary-item">
      <div class="value">{totalTests - successCount}</div>
      <div class="label">å¤±è´¥æµ‹è¯•</div>
    </div>
    <div class="summary-item">
      <div class="value">{totalTests}</div>
      <div class="label">æ€»æµ‹è¯•æ•°</div>
    </div>
  </div>

  <div class="test-results">
    {testResults.map((result, index) => (
      <div class="test-card">
        <div class={`test-header ${result.success ? 'success' : 'error'}`}>
          <div class="test-name">
            <span>{result.success ? 'âœ…' : 'âŒ'}</span>
            æµ‹è¯• {index + 1}: {result.name}
          </div>
          <div class="test-duration">{result.duration.toFixed(2)}ms</div>
        </div>
        <div class="test-content">
          <div class="test-details">
            <strong>æµ‹è¯•è¯¦æƒ…:</strong>
            <pre>{JSON.stringify(result.details, null, 2)}</pre>
          </div>
          {result.error && (
            <div class="error-message">
              <strong>é”™è¯¯ä¿¡æ¯:</strong> {result.error}
            </div>
          )}
        </div>
      </div>
    ))}
  </div>

  <script define:vars={{ testResults }}>
    console.log('ğŸ“Š æ€§èƒ½ç›‘æ§æµ‹è¯•é¡µé¢å·²åŠ è½½');
    console.log('ğŸ“Š æµ‹è¯•ç»“æœ:', JSON.stringify(testResults, null, 2));

    // æ¨¡æ‹Ÿå‡½æ•°
    function simulateConfigLoad() {
      console.log('ğŸ”„ æ¨¡æ‹Ÿé…ç½®åŠ è½½...');
      // è¿™é‡Œä¼šè§¦å‘æ€§èƒ½ç›‘æ§é¢æ¿çš„æ›´æ–°
    }

    function simulateCategoryLoad() {
      console.log('ğŸ“‚ æ¨¡æ‹Ÿåˆ†ç±»åŠ è½½...');
    }

    function simulateNetworkRequest() {
      console.log('ğŸŒ æ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚...');
    }

    function simulateUserInteraction() {
      console.log('ğŸ‘† æ¨¡æ‹Ÿç”¨æˆ·äº¤äº’...');
    }

    function simulateHighLoad() {
      console.log('âš¡ æ¨¡æ‹Ÿé«˜è´Ÿè½½åœºæ™¯...');
    }

    function resetMonitor() {
      console.log('ğŸ”„ é‡ç½®æ€§èƒ½ç›‘æ§...');
    }

    // ä½¿å‡½æ•°å…¨å±€å¯ç”¨
    window.simulateConfigLoad = simulateConfigLoad;
    window.simulateCategoryLoad = simulateCategoryLoad;
    window.simulateNetworkRequest = simulateNetworkRequest;
    window.simulateUserInteraction = simulateUserInteraction;
    window.simulateHighLoad = simulateHighLoad;
    window.resetMonitor = resetMonitor;
  </script>
</body>
</html>
