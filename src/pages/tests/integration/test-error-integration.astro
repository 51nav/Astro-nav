---
/**
 * é”™è¯¯å¤„ç†é›†æˆæµ‹è¯•é¡µé¢
 * Week 3 - ä»»åŠ¡2.3é›†æˆéªŒè¯
 */

import ErrorMessage from '../../../components/ErrorMessage.astro';
import { ConfigManager } from '../../../utils/ConfigManager';
import { LazyLoader } from '../../../utils/LazyLoader';
import { PreloadStrategy } from '../../../utils/PreloadStrategy';
import { defaultErrorHandler } from '../../../utils/ErrorHandler';

// æµ‹è¯•ç»“æœæ¥å£
interface TestResult {
  name: string;
  success: boolean;
  duration: number;
  details: any;
  error?: string;
}

async function runTest(name: string, testFn: () => Promise<any>): Promise<TestResult> {
  const startTime = performance.now();
  try {
    const result = await testFn();
    return {
      name,
      success: true,
      duration: performance.now() - startTime,
      details: result
    };
  } catch (error) {
    return {
      name,
      success: false,
      duration: performance.now() - startTime,
      details: {},
      error: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
    };
  }
}

// åˆå§‹åŒ–ç»„ä»¶
const configManager = new ConfigManager();
const lazyLoader = new LazyLoader(configManager);
const preloadStrategy = new PreloadStrategy(lazyLoader, configManager);

// æ‰§è¡Œé›†æˆæµ‹è¯•
const testResults: TestResult[] = [
  // æµ‹è¯•1: é…ç½®åŠ è½½é”™è¯¯å¤„ç†
  await runTest('é…ç½®åŠ è½½é”™è¯¯å¤„ç†', async () => {
    // å°è¯•åŠ è½½ä¸å­˜åœ¨çš„é…ç½®æ–‡ä»¶
    const invalidConfigManager = new ConfigManager('/invalid-config.json');
    const result = await invalidConfigManager.loadConfig();
    
    return {
      loadFailed: !result.success,
      hasErrorMessage: !!result.error,
      errorHandled: result.error !== undefined,
      gracefulDegradation: !result.success && result.error.length > 0
    };
  }),

  // æµ‹è¯•2: åˆ†ç±»åŠ è½½é”™è¯¯å¤„ç†
  await runTest('åˆ†ç±»åŠ è½½é”™è¯¯å¤„ç†', async () => {
    // é¦–å…ˆåŠ è½½æ­£å¸¸é…ç½®
    const configResult = await configManager.loadConfig();
    
    if (!configResult.success) {
      throw new Error('é…ç½®åŠ è½½å¤±è´¥ï¼Œæ— æ³•æµ‹è¯•åˆ†ç±»åŠ è½½é”™è¯¯');
    }
    
    // å°è¯•åŠ è½½ä¸å­˜åœ¨çš„åˆ†ç±»
    const invalidCategoryResult = await lazyLoader.loadCategory(999);
    
    return {
      configLoaded: configResult.success,
      categoryLoadFailed: !invalidCategoryResult.success,
      hasErrorMessage: !!invalidCategoryResult.error,
      errorHandled: invalidCategoryResult.error !== undefined,
      fallbackWorking: !invalidCategoryResult.success
    };
  }),

  // æµ‹è¯•3: é¢„åŠ è½½é”™è¯¯å¤„ç†
  await runTest('é¢„åŠ è½½é”™è¯¯å¤„ç†', async () => {
    // ç¡®ä¿é…ç½®å·²åŠ è½½
    const configResult = await configManager.loadConfig();
    
    if (!configResult.success) {
      throw new Error('é…ç½®åŠ è½½å¤±è´¥ï¼Œæ— æ³•æµ‹è¯•é¢„åŠ è½½é”™è¯¯');
    }
    
    // æ‰§è¡Œé¢„åŠ è½½ï¼ˆå¯èƒ½åŒ…å«é”™è¯¯ï¼‰
    const preloadResult = await preloadStrategy.executePreload();
    const preloadStats = preloadStrategy.getPreloadStats();
    
    return {
      configLoaded: configResult.success,
      preloadExecuted: true,
      preloadStats,
      hasFailures: preloadStats.failureCount > 0,
      errorHandling: preloadStats.failureCount === 0 || preloadStats.successCount > 0
    };
  }),

  // æµ‹è¯•4: ç½‘ç»œé”™è¯¯æ¢å¤
  await runTest('ç½‘ç»œé”™è¯¯æ¢å¤', async () => {
    // æ¨¡æ‹Ÿç½‘ç»œé”™è¯¯
    const networkError = new Error('Network request failed');
    networkError.name = 'NetworkError';
    
    const errorResult = await defaultErrorHandler.handleError(networkError, {
      type: 'network',
      operation: 'loadCategory'
    });
    
    // æ£€æŸ¥é™çº§ç­–ç•¥
    const hasNetworkFallback = !errorResult.success && errorResult.error?.fallbackAvailable;
    
    return {
      errorDetected: !errorResult.success,
      errorType: errorResult.error?.type,
      fallbackAvailable: errorResult.error?.fallbackAvailable,
      userFriendlyMessage: errorResult.error?.userMessage,
      networkErrorHandled: hasNetworkFallback
    };
  }),

  // æµ‹è¯•5: ç¼“å­˜é”™è¯¯å¤„ç†
  await runTest('ç¼“å­˜é”™è¯¯å¤„ç†', async () => {
    // è·å–ç¼“å­˜ç»Ÿè®¡
    const cacheStatsBefore = lazyLoader.getCacheStats();
    
    // æ¨¡æ‹Ÿç¼“å­˜é”™è¯¯
    const cacheError = new Error('Cache corruption detected');
    const errorResult = await defaultErrorHandler.handleError(cacheError, {
      type: 'cache',
      operation: 'cache'
    });
    
    // æ¸…ç†ç¼“å­˜
    lazyLoader.clearCache();
    const cacheStatsAfter = lazyLoader.getCacheStats();
    
    return {
      cacheSizeBefore: cacheStatsBefore.cacheSize,
      cacheSizeAfter: cacheStatsAfter.cacheSize,
      cacheCleared: cacheStatsAfter.cacheSize === 0,
      errorHandled: !errorResult.success,
      fallbackAvailable: errorResult.error?.fallbackAvailable,
      cacheErrorRecovery: cacheStatsAfter.cacheSize === 0
    };
  }),

  // æµ‹è¯•6: ç³»ç»Ÿå¥åº·ç›‘æ§
  await runTest('ç³»ç»Ÿå¥åº·ç›‘æ§', async () => {
    // è§¦å‘ä¸€äº›é”™è¯¯æ¥æµ‹è¯•å¥åº·ç›‘æ§
    const errors = [
      new Error('Test network error'),
      new Error('Test timeout'),
      new SyntaxError('Test parse error')
    ];
    
    for (const error of errors) {
      await defaultErrorHandler.handleError(error);
    }
    
    const health = defaultErrorHandler.getSystemHealth();
    const stats = defaultErrorHandler.getErrorStats();
    
    return {
      systemStatus: health.status,
      systemScore: health.score,
      totalErrors: stats.totalErrors,
      issueCount: health.issues.length,
      recommendationCount: health.recommendations.length,
      healthMonitoringWorking: health.score >= 0 && health.score <= 100
    };
  }),

  // æµ‹è¯•7: é”™è¯¯æ¢å¤ç­–ç•¥
  await runTest('é”™è¯¯æ¢å¤ç­–ç•¥', async () => {
    // æµ‹è¯•ä¸åŒç±»å‹é”™è¯¯çš„æ¢å¤ç­–ç•¥
    const recoveryTests = [
      {
        type: 'config',
        error: new Error('Config load failed'),
        expectedFallback: true
      },
      {
        type: 'parse',
        error: new SyntaxError('JSON parse error'),
        expectedFallback: true
      },
      {
        type: 'preload',
        error: new Error('Preload failed'),
        expectedFallback: true
      }
    ];
    
    const recoveryResults = [];
    
    for (const test of recoveryTests) {
      const result = await defaultErrorHandler.handleError(test.error, {
        type: test.type,
        operation: 'test'
      });
      
      recoveryResults.push({
        type: test.type,
        errorHandled: !result.success,
        fallbackAvailable: result.error?.fallbackAvailable,
        expectedFallback: test.expectedFallback,
        recoveryWorking: result.error?.fallbackAvailable === test.expectedFallback
      });
    }
    
    return {
      recoveryTests: recoveryResults,
      allRecoveryWorking: recoveryResults.every(r => r.recoveryWorking),
      totalTests: recoveryResults.length
    };
  }),

  // æµ‹è¯•8: ç”¨æˆ·ä½“éªŒä¼˜åŒ–
  await runTest('ç”¨æˆ·ä½“éªŒä¼˜åŒ–', async () => {
    // æµ‹è¯•ç”¨æˆ·å‹å¥½çš„é”™è¯¯æ¶ˆæ¯
    const userExperienceTests = [
      {
        error: new Error('fetch failed'),
        context: { type: 'network' },
        expectedMessage: 'ç½‘ç»œè¿æ¥ä¸ç¨³å®š'
      },
      {
        error: new Error('timeout'),
        context: { type: 'timeout' },
        expectedMessage: 'åŠ è½½è¶…æ—¶'
      },
      {
        error: new SyntaxError('JSON error'),
        context: { type: 'parse' },
        expectedMessage: 'æ•°æ®æ ¼å¼é”™è¯¯'
      }
    ];
    
    const userExperienceResults = [];
    
    for (const test of userExperienceTests) {
      const result = await defaultErrorHandler.handleError(test.error, test.context);
      
      userExperienceResults.push({
        errorType: result.error?.type,
        userMessage: result.error?.userMessage,
        isFriendly: result.error?.userMessage && 
                   result.error.userMessage.length > 0 && 
                   !result.error.userMessage.includes('Error:'),
        expectedKeyword: test.expectedMessage
      });
    }
    
    return {
      userExperienceTests: userExperienceResults,
      allFriendly: userExperienceResults.every(r => r.isFriendly),
      totalTests: userExperienceResults.length
    };
  })
];

const successCount = testResults.filter(r => r.success).length;
const totalTests = testResults.length;
const successRate = (successCount / totalTests * 100).toFixed(1);

// è·å–æœ€ç»ˆç³»ç»ŸçŠ¶æ€
const finalHealth = defaultErrorHandler.getSystemHealth();
const finalStats = defaultErrorHandler.getErrorStats();
---

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>é”™è¯¯å¤„ç†é›†æˆæµ‹è¯•</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    
    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
      margin-bottom: 30px;
      text-align: center;
    }
    
    .system-status {
      background: white;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin-bottom: 30px;
    }
    
    .status-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    
    .status-item {
      text-align: center;
      padding: 20px;
      border-radius: 8px;
      background: #f8fafc;
      border: 1px solid #e2e8f0;
    }
    
    .status-item.healthy {
      background: #d1fae5;
      border-color: #10b981;
      color: #065f46;
    }
    
    .status-item.warning {
      background: #fef3c7;
      border-color: #f59e0b;
      color: #92400e;
    }
    
    .status-item.critical {
      background: #fee2e2;
      border-color: #ef4444;
      color: #991b1b;
    }
    
    .status-value {
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .status-label {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .error-showcase {
      background: white;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin-bottom: 30px;
    }
    
    .showcase-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    
    .summary {
      background: white;
      padding: 25px;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin-bottom: 30px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
    }
    
    .summary-item {
      text-align: center;
      padding: 20px;
      border-radius: 8px;
      background: #f8f9fa;
    }
    
    .summary-item.success {
      background: #d4edda;
      color: #155724;
    }
    
    .summary-item.warning {
      background: #fff3cd;
      color: #856404;
    }
    
    .summary-item .value {
      font-size: 32px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .summary-item .label {
      font-size: 14px;
      opacity: 0.8;
    }
    
    .test-results {
      display: grid;
      gap: 20px;
    }
    
    .test-card {
      background: white;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      overflow: hidden;
    }
    
    .test-header {
      padding: 20px;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .test-header.success {
      background: #d4edda;
      color: #155724;
    }
    
    .test-header.error {
      background: #f8d7da;
      color: #721c24;
    }
    
    .test-name {
      font-size: 18px;
      font-weight: 600;
    }
    
    .test-duration {
      font-size: 14px;
      opacity: 0.8;
    }
    
    .test-content {
      padding: 20px;
    }
    
    .test-details {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 15px;
      margin-top: 15px;
    }
    
    .test-details pre {
      margin: 0;
      font-size: 14px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    
    .error-message {
      background: #f8d7da;
      color: #721c24;
      padding: 15px;
      border-radius: 8px;
      margin-top: 15px;
      border-left: 4px solid #dc3545;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>ğŸ›¡ï¸ é”™è¯¯å¤„ç†é›†æˆæµ‹è¯•</h1>
    <div class="subtitle">Week 3 - ä»»åŠ¡2.3é›†æˆéªŒè¯ | æµ‹è¯•æ—¶é—´: {new Date().toLocaleString()}</div>
  </div>

  <!-- ç³»ç»ŸçŠ¶æ€ä»ªè¡¨æ¿ -->
  <div class="system-status">
    <h2>ğŸ¥ ç³»ç»Ÿå¥åº·çŠ¶æ€</h2>
    <div class="status-grid">
      <div class={`status-item ${finalHealth.status === 'healthy' ? 'healthy' : finalHealth.status === 'warning' ? 'warning' : 'critical'}`}>
        <div class="status-value">{finalHealth.status.toUpperCase()}</div>
        <div class="status-label">ç³»ç»ŸçŠ¶æ€</div>
      </div>
      <div class={`status-item ${finalHealth.score >= 80 ? 'healthy' : finalHealth.score >= 60 ? 'warning' : 'critical'}`}>
        <div class="status-value">{finalHealth.score}</div>
        <div class="status-label">å¥åº·è¯„åˆ†</div>
      </div>
      <div class="status-item">
        <div class="status-value">{finalStats.totalErrors}</div>
        <div class="status-label">é”™è¯¯è®°å½•</div>
      </div>
      <div class="status-item">
        <div class="status-value">{finalHealth.issues.length}</div>
        <div class="status-label">å½“å‰é—®é¢˜</div>
      </div>
      <div class="status-item">
        <div class="status-value">{finalHealth.recommendations.length}</div>
        <div class="status-label">ä¼˜åŒ–å»ºè®®</div>
      </div>
    </div>
  </div>

  <!-- é”™è¯¯å¤„ç†å±•ç¤º -->
  <div class="error-showcase">
    <h2>ğŸš¨ é”™è¯¯å¤„ç†å±•ç¤º</h2>
    <div class="showcase-grid">
      <ErrorMessage 
        type="NETWORK_ERROR"
        severity="high"
        message="ç½‘ç»œè¿æ¥ä¸ç¨³å®šï¼Œæ­£åœ¨é‡è¯•..."
        showRetry={true}
        showDetails={true}
        details="é›†æˆæµ‹è¯•ä¸­æ£€æµ‹åˆ°çš„ç½‘ç»œé”™è¯¯"
        dismissible={true}
      />
      
      <ErrorMessage 
        type="CONFIG_ERROR"
        severity="critical"
        message="é…ç½®åŠ è½½å¤±è´¥ï¼Œå·²å¯ç”¨é™çº§æ¨¡å¼"
        showRetry={true}
        dismissible={true}
      />
    </div>
  </div>

  <!-- æµ‹è¯•ç»“æœ -->
  <div class="summary">
    <div class={`summary-item ${successRate === '100.0' ? 'success' : 'warning'}`}>
      <div class="value">{successRate}%</div>
      <div class="label">é›†æˆæµ‹è¯•é€šè¿‡ç‡</div>
    </div>
    <div class="summary-item">
      <div class="value">{successCount}</div>
      <div class="label">é€šè¿‡æµ‹è¯•</div>
    </div>
    <div class="summary-item">
      <div class="value">{totalTests - successCount}</div>
      <div class="label">å¤±è´¥æµ‹è¯•</div>
    </div>
    <div class={`summary-item ${finalHealth.status === 'healthy' ? 'success' : 'warning'}`}>
      <div class="value">{finalHealth.status}</div>
      <div class="label">ç³»ç»ŸçŠ¶æ€</div>
    </div>
  </div>

  <div class="test-results">
    {testResults.map((result, index) => (
      <div class="test-card">
        <div class={`test-header ${result.success ? 'success' : 'error'}`}>
          <div class="test-name">
            <span>{result.success ? 'âœ…' : 'âŒ'}</span>
            é›†æˆæµ‹è¯• {index + 1}: {result.name}
          </div>
          <div class="test-duration">{result.duration.toFixed(2)}ms</div>
        </div>
        <div class="test-content">
          <div class="test-details">
            <strong>æµ‹è¯•è¯¦æƒ…:</strong>
            <pre>{JSON.stringify(result.details, null, 2)}</pre>
          </div>
          {result.error && (
            <div class="error-message">
              <strong>é”™è¯¯ä¿¡æ¯:</strong> {result.error}
            </div>
          )}
        </div>
      </div>
    ))}
  </div>

  <script define:vars={{ testResults, finalHealth, finalStats }}>
    console.log('ğŸ›¡ï¸ é”™è¯¯å¤„ç†é›†æˆæµ‹è¯•é¡µé¢å·²åŠ è½½');
    console.log('ğŸ“Š é›†æˆæµ‹è¯•ç»“æœ:', JSON.stringify(testResults, null, 2));
    console.log('ğŸ¥ ç³»ç»Ÿå¥åº·çŠ¶æ€:', JSON.stringify(finalHealth, null, 2));
    console.log('ğŸ“Š é”™è¯¯ç»Ÿè®¡:', JSON.stringify(finalStats, null, 2));
  </script>
</body>
</html>
