---
/**
 * æ€§èƒ½ç›‘æ§é›†æˆæµ‹è¯•é¡µé¢
 * Week 3 - ä»»åŠ¡2.2é›†æˆéªŒè¯
 */

import PerformanceMonitor from '../../../components/PerformanceMonitor.astro';
import { ConfigManager } from '../../../utils/ConfigManager';
import { LazyLoader } from '../../../utils/LazyLoader';
import { PreloadStrategy } from '../../../utils/PreloadStrategy';
import { PerformanceMonitor as PerformanceMonitorClass } from '../../../utils/PerformanceMonitor';

// æµ‹è¯•ç»“æœæ¥å£
interface TestResult {
  name: string;
  success: boolean;
  duration: number;
  details: any;
  error?: string;
}

async function runTest(name: string, testFn: () => Promise<any>): Promise<TestResult> {
  const startTime = performance.now();
  try {
    const result = await testFn();
    return {
      name,
      success: true,
      duration: performance.now() - startTime,
      details: result
    };
  } catch (error) {
    return {
      name,
      success: false,
      duration: performance.now() - startTime,
      details: {},
      error: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
    };
  }
}

// åˆå§‹åŒ–ç»„ä»¶
const configManager = new ConfigManager();
const lazyLoader = new LazyLoader(configManager);
const preloadStrategy = new PreloadStrategy(lazyLoader, configManager);
const performanceMonitor = new PerformanceMonitorClass();

// æ‰§è¡Œé›†æˆæµ‹è¯•
const testResults: TestResult[] = [
  // æµ‹è¯•1: å®Œæ•´æ€§èƒ½ç›‘æ§æµç¨‹
  await runTest('å®Œæ•´æ€§èƒ½ç›‘æ§æµç¨‹', async () => {
    // 1. ç›‘æ§é…ç½®åŠ è½½
    const configStartTime = performance.now();
    const configResult = await configManager.loadOptimizedConfig();
    const configLoadTime = performance.now() - configStartTime;
    
    performanceMonitor.recordConfigLoadTime(configLoadTime);
    
    // 2. ç›‘æ§åˆ†ç±»åŠ è½½
    if (configResult.success) {
      const categories = configManager.getAllCategoryIndexes();
      if (categories.length > 0) {
        const categoryStartTime = performance.now();
        const categoryResult = await lazyLoader.loadCategory(categories[0]);
        const categoryLoadTime = performance.now() - categoryStartTime;
        
        performanceMonitor.recordCategoryLoadTime(categoryLoadTime);
        performanceMonitor.recordNetworkRequest(categoryLoadTime, categoryResult.success);
      }
    }
    
    // 3. ç›‘æ§é¢„åŠ è½½
    await preloadStrategy.executePreload();
    const preloadStats = preloadStrategy.getPreloadStats();
    performanceMonitor.updatePreloadMetrics(
      preloadStats.totalPreloads,
      preloadStats.successRate,
      preloadStats.cacheHitRate
    );
    
    // 4. ç›‘æ§ç¼“å­˜
    const cacheStats = lazyLoader.getCacheStats();
    performanceMonitor.updateCacheMetrics(
      cacheStats.cacheSize,
      cacheStats.maxCacheSize,
      cacheStats.hitRate
    );
    
    const metrics = performanceMonitor.getMetrics();
    const score = performanceMonitor.getPerformanceScore();
    
    return {
      configLoaded: configResult.success,
      configLoadTime,
      categoryLoadTime: metrics.categoryLoadTime,
      preloadCount: metrics.preloadCount,
      cacheSize: metrics.cacheSize,
      performanceScore: score,
      monitoringWorking: metrics.configLoadTime > 0 && score > 0
    };
  }),

  // æµ‹è¯•2: å®æ—¶æ€§èƒ½ç›‘æ§
  await runTest('å®æ—¶æ€§èƒ½ç›‘æ§', async () => {
    const categories = configManager.getAllCategoryIndexes();
    const monitoringResults = [];
    
    // æ¨¡æ‹Ÿå¤šæ¬¡æ“ä½œå¹¶ç›‘æ§
    for (let i = 0; i < 5; i++) {
      const startTime = performance.now();
      
      // æ¨¡æ‹Ÿç”¨æˆ·äº¤äº’
      const interactionTime = Math.random() * 50 + 20;
      performanceMonitor.recordUserInteraction(interactionTime);
      
      // æ¨¡æ‹Ÿåˆ†ç±»åŠ è½½
      if (categories.length > 0) {
        const categoryIndex = categories[i % categories.length];
        const result = await lazyLoader.loadCategory(categoryIndex);
        const loadTime = performance.now() - startTime;
        
        performanceMonitor.recordCategoryLoadTime(loadTime);
        performanceMonitor.recordNetworkRequest(loadTime, result.success);
        
        monitoringResults.push({
          iteration: i + 1,
          categoryIndex,
          loadTime,
          success: result.success,
          interactionTime
        });
      }
    }
    
    const metrics = performanceMonitor.getMetrics();
    
    return {
      iterations: monitoringResults.length,
      results: monitoringResults,
      totalInteractions: metrics.userInteractionCount,
      avgInteractionTime: metrics.avgInteractionResponseTime,
      totalNetworkRequests: metrics.networkRequestCount,
      avgResponseTime: metrics.avgResponseTime,
      realTimeMonitoringWorking: monitoringResults.length > 0 && metrics.userInteractionCount > 0
    };
  }),

  // æµ‹è¯•3: æ€§èƒ½è­¦å‘Šç³»ç»Ÿ
  await runTest('æ€§èƒ½è­¦å‘Šç³»ç»Ÿ', async () => {
    // æ¸…ç†ä¹‹å‰çš„è­¦å‘Š
    performanceMonitor.reset();
    
    // è§¦å‘å„ç§è­¦å‘Šæ¡ä»¶
    const warningTriggers = [
      { action: 'slowConfig', value: 1200 },
      { action: 'slowCategory', value: 2200 },
      { action: 'lowCacheHit', value: 45 },
      { action: 'slowNetwork', value: 1800 },
      { action: 'slowInteraction', value: 150 }
    ];
    
    for (const trigger of warningTriggers) {
      switch (trigger.action) {
        case 'slowConfig':
          performanceMonitor.recordConfigLoadTime(trigger.value);
          break;
        case 'slowCategory':
          performanceMonitor.recordCategoryLoadTime(trigger.value);
          break;
        case 'lowCacheHit':
          performanceMonitor.updateCacheMetrics(3, 10, trigger.value);
          break;
        case 'slowNetwork':
          performanceMonitor.recordNetworkRequest(trigger.value, true);
          break;
        case 'slowInteraction':
          performanceMonitor.recordUserInteraction(trigger.value);
          break;
      }
    }
    
    const alerts = performanceMonitor.getAlerts();
    const recommendations = performanceMonitor.getRecommendations();
    
    return {
      warningTriggers,
      alertCount: alerts.length,
      recommendationCount: recommendations.length,
      alertTypes: [...new Set(alerts.map(a => a.type))],
      alertMetrics: [...new Set(alerts.map(a => a.metric))],
      recommendationCategories: [...new Set(recommendations.map(r => r.category))],
      warningSystemWorking: alerts.length > 0 && recommendations.length > 0
    };
  }),

  // æµ‹è¯•4: æ€§èƒ½ä¼˜åŒ–å»ºè®®
  await runTest('æ€§èƒ½ä¼˜åŒ–å»ºè®®', async () => {
    // åˆ›å»ºä¸åŒçš„æ€§èƒ½åœºæ™¯
    const scenarios = [
      {
        name: 'optimal',
        config: { configTime: 200, categoryTime: 50, cacheHit: 95, networkTime: 100 }
      },
      {
        name: 'suboptimal',
        config: { configTime: 800, categoryTime: 300, cacheHit: 70, networkTime: 800 }
      },
      {
        name: 'poor',
        config: { configTime: 1500, categoryTime: 2000, cacheHit: 40, networkTime: 2000 }
      }
    ];
    
    const scenarioResults = [];
    
    for (const scenario of scenarios) {
      const testMonitor = new PerformanceMonitorClass();
      
      testMonitor.recordConfigLoadTime(scenario.config.configTime);
      testMonitor.recordCategoryLoadTime(scenario.config.categoryTime);
      testMonitor.updateCacheMetrics(5, 10, scenario.config.cacheHit);
      testMonitor.recordNetworkRequest(scenario.config.networkTime, true);
      
      const score = testMonitor.getPerformanceScore();
      const recommendations = testMonitor.getRecommendations();
      
      scenarioResults.push({
        scenario: scenario.name,
        score,
        recommendationCount: recommendations.length,
        recommendations: recommendations.map(r => ({
          category: r.category,
          impact: r.impact,
          actionable: r.actionable
        }))
      });
    }
    
    return {
      scenarios: scenarioResults,
      optimalScore: scenarioResults[0].score,
      poorScore: scenarioResults[2].score,
      scoreVariation: scenarioResults[0].score - scenarioResults[2].score,
      recommendationSystemWorking: scenarioResults.every(s => 
        s.scenario === 'optimal' ? s.recommendationCount <= 1 : s.recommendationCount > 0
      )
    };
  }),

  // æµ‹è¯•5: å†…å­˜ç›‘æ§é›†æˆ
  await runTest('å†…å­˜ç›‘æ§é›†æˆ', async () => {
    // æ‰§è¡Œä¸€ç³»åˆ—æ“ä½œæ¥æµ‹è¯•å†…å­˜ç›‘æ§
    const operations = [];
    
    for (let i = 0; i < 10; i++) {
      // åŠ è½½åˆ†ç±»æ•°æ®
      const categories = configManager.getAllCategoryIndexes();
      if (categories.length > 0) {
        await lazyLoader.loadCategory(categories[i % categories.length]);
      }
      
      // æ‰§è¡Œé¢„åŠ è½½
      await preloadStrategy.executePreload();
      
      // è®°å½•å†…å­˜ä½¿ç”¨æƒ…å†µ
      const metrics = performanceMonitor.getMetrics();
      operations.push({
        iteration: i + 1,
        memoryUsage: metrics.memoryUsage,
        cacheSize: lazyLoader.getCacheStats().cacheSize
      });
    }
    
    const finalMetrics = performanceMonitor.getMetrics();
    
    return {
      operations: operations.length,
      finalMemoryUsage: finalMetrics.memoryUsage,
      finalCacheSize: lazyLoader.getCacheStats().cacheSize,
      memoryEfficient: finalMetrics.memoryUsage < 50, // å°äº50MB
      memoryMonitoringWorking: operations.length > 0
    };
  }),

  // æµ‹è¯•6: æ€§èƒ½æ•°æ®å¯¼å‡º
  await runTest('æ€§èƒ½æ•°æ®å¯¼å‡º', async () => {
    // ç”Ÿæˆä¸€äº›æ€§èƒ½æ•°æ®
    performanceMonitor.recordConfigLoadTime(300);
    performanceMonitor.recordCategoryLoadTime(150);
    performanceMonitor.recordUserInteraction(45);
    performanceMonitor.recordNetworkRequest(200, true);
    
    const exportData = performanceMonitor.exportReport();
    
    let parsedData;
    try {
      parsedData = JSON.parse(exportData);
    } catch (error) {
      throw new Error('å¯¼å‡ºæ•°æ®æ ¼å¼é”™è¯¯');
    }
    
    return {
      exportSize: exportData.length,
      hasMetrics: !!parsedData.metrics,
      hasAlerts: Array.isArray(parsedData.alerts),
      hasRecommendations: Array.isArray(parsedData.recommendations),
      hasScore: typeof parsedData.score === 'number',
      hasExportTime: !!parsedData.exportTime,
      metricsComplete: !!(parsedData.metrics.configLoadTime && 
                         parsedData.metrics.categoryLoadTime &&
                         parsedData.metrics.userInteractionCount),
      exportWorking: exportData.length > 0 && !!parsedData.metrics
    };
  })
];

const successCount = testResults.filter(r => r.success).length;
const totalTests = testResults.length;
const successRate = (successCount / totalTests * 100).toFixed(1);

// è®¡ç®—æ€§èƒ½è¯„åˆ†
const performanceScore = performanceMonitor.getPerformanceScore();
const finalMetrics = performanceMonitor.getMetrics();
---

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ€§èƒ½ç›‘æ§é›†æˆæµ‹è¯•</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    
    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
      margin-bottom: 30px;
      text-align: center;
    }
    
    .performance-dashboard {
      background: white;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin-bottom: 30px;
    }
    
    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    
    .dashboard-item {
      text-align: center;
      padding: 20px;
      border-radius: 8px;
      background: #f8fafc;
      border: 1px solid #e2e8f0;
    }
    
    .dashboard-item.excellent {
      background: #d1fae5;
      border-color: #10b981;
    }
    
    .dashboard-item.good {
      background: #dbeafe;
      border-color: #3b82f6;
    }
    
    .dashboard-item.warning {
      background: #fef3c7;
      border-color: #f59e0b;
    }
    
    .dashboard-item.poor {
      background: #fee2e2;
      border-color: #ef4444;
    }
    
    .dashboard-value {
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .dashboard-label {
      font-size: 12px;
      color: #6b7280;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .summary {
      background: white;
      padding: 25px;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin-bottom: 30px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
    }
    
    .summary-item {
      text-align: center;
      padding: 20px;
      border-radius: 8px;
      background: #f8f9fa;
    }
    
    .summary-item.success {
      background: #d4edda;
      color: #155724;
    }
    
    .summary-item.warning {
      background: #fff3cd;
      color: #856404;
    }
    
    .summary-item .value {
      font-size: 32px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .summary-item .label {
      font-size: 14px;
      opacity: 0.8;
    }
    
    .test-results {
      display: grid;
      gap: 20px;
    }
    
    .test-card {
      background: white;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      overflow: hidden;
    }
    
    .test-header {
      padding: 20px;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .test-header.success {
      background: #d4edda;
      color: #155724;
    }
    
    .test-header.error {
      background: #f8d7da;
      color: #721c24;
    }
    
    .test-name {
      font-size: 18px;
      font-weight: 600;
    }
    
    .test-duration {
      font-size: 14px;
      opacity: 0.8;
    }
    
    .test-content {
      padding: 20px;
    }
    
    .test-details {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 15px;
      margin-top: 15px;
    }
    
    .test-details pre {
      margin: 0;
      font-size: 14px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    
    .error-message {
      background: #f8d7da;
      color: #721c24;
      padding: 15px;
      border-radius: 8px;
      margin-top: 15px;
      border-left: 4px solid #dc3545;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>ğŸ“Š æ€§èƒ½ç›‘æ§é›†æˆæµ‹è¯•</h1>
    <div class="subtitle">Week 3 - ä»»åŠ¡2.2é›†æˆéªŒè¯ | æµ‹è¯•æ—¶é—´: {new Date().toLocaleString()}</div>
  </div>

  <!-- æ€§èƒ½ä»ªè¡¨æ¿ -->
  <div class="performance-dashboard">
    <h2>ğŸ›ï¸ å®æ—¶æ€§èƒ½ä»ªè¡¨æ¿</h2>
    <div class="dashboard-grid">
      <div class={`dashboard-item ${performanceScore >= 90 ? 'excellent' : performanceScore >= 70 ? 'good' : performanceScore >= 50 ? 'warning' : 'poor'}`}>
        <div class="dashboard-value">{performanceScore}</div>
        <div class="dashboard-label">æ€§èƒ½è¯„åˆ†</div>
      </div>
      <div class={`dashboard-item ${finalMetrics.configLoadTime <= 500 ? 'excellent' : finalMetrics.configLoadTime <= 1000 ? 'good' : 'warning'}`}>
        <div class="dashboard-value">{finalMetrics.configLoadTime.toFixed(0)}ms</div>
        <div class="dashboard-label">é…ç½®åŠ è½½æ—¶é—´</div>
      </div>
      <div class={`dashboard-item ${finalMetrics.avgCategoryLoadTime <= 100 ? 'excellent' : finalMetrics.avgCategoryLoadTime <= 300 ? 'good' : 'warning'}`}>
        <div class="dashboard-value">{finalMetrics.avgCategoryLoadTime.toFixed(0)}ms</div>
        <div class="dashboard-label">å¹³å‡åˆ†ç±»åŠ è½½</div>
      </div>
      <div class={`dashboard-item ${finalMetrics.cacheHitRate >= 90 ? 'excellent' : finalMetrics.cacheHitRate >= 70 ? 'good' : 'warning'}`}>
        <div class="dashboard-value">{finalMetrics.cacheHitRate.toFixed(1)}%</div>
        <div class="dashboard-label">ç¼“å­˜å‘½ä¸­ç‡</div>
      </div>
      <div class={`dashboard-item ${finalMetrics.memoryUsage <= 30 ? 'excellent' : finalMetrics.memoryUsage <= 50 ? 'good' : 'warning'}`}>
        <div class="dashboard-value">{finalMetrics.memoryUsage.toFixed(1)}MB</div>
        <div class="dashboard-label">å†…å­˜ä½¿ç”¨</div>
      </div>
      <div class="dashboard-item good">
        <div class="dashboard-value">{finalMetrics.networkRequestCount}</div>
        <div class="dashboard-label">ç½‘ç»œè¯·æ±‚æ•°</div>
      </div>
    </div>
  </div>

  <!-- æ€§èƒ½ç›‘æ§é¢æ¿ -->
  <PerformanceMonitor 
    visible={true}
    position="bottom-right"
    collapsible={true}
    defaultCollapsed={false}
    updateInterval={2000}
  />

  <!-- æµ‹è¯•ç»“æœ -->
  <div class="summary">
    <div class={`summary-item ${successRate === '100.0' ? 'success' : 'warning'}`}>
      <div class="value">{successRate}%</div>
      <div class="label">é›†æˆæµ‹è¯•é€šè¿‡ç‡</div>
    </div>
    <div class="summary-item">
      <div class="value">{successCount}</div>
      <div class="label">é€šè¿‡æµ‹è¯•</div>
    </div>
    <div class="summary-item">
      <div class="value">{totalTests - successCount}</div>
      <div class="label">å¤±è´¥æµ‹è¯•</div>
    </div>
    <div class={`summary-item ${performanceScore >= 80 ? 'success' : 'warning'}`}>
      <div class="value">{performanceScore}</div>
      <div class="label">æ€§èƒ½è¯„åˆ†</div>
    </div>
  </div>

  <div class="test-results">
    {testResults.map((result, index) => (
      <div class="test-card">
        <div class={`test-header ${result.success ? 'success' : 'error'}`}>
          <div class="test-name">
            <span>{result.success ? 'âœ…' : 'âŒ'}</span>
            é›†æˆæµ‹è¯• {index + 1}: {result.name}
          </div>
          <div class="test-duration">{result.duration.toFixed(2)}ms</div>
        </div>
        <div class="test-content">
          <div class="test-details">
            <strong>æµ‹è¯•è¯¦æƒ…:</strong>
            <pre>{JSON.stringify(result.details, null, 2)}</pre>
          </div>
          {result.error && (
            <div class="error-message">
              <strong>é”™è¯¯ä¿¡æ¯:</strong> {result.error}
            </div>
          )}
        </div>
      </div>
    ))}
  </div>

  <script define:vars={{ testResults, performanceScore, finalMetrics }}>
    console.log('ğŸ“Š æ€§èƒ½ç›‘æ§é›†æˆæµ‹è¯•é¡µé¢å·²åŠ è½½');
    console.log('ğŸ“Š é›†æˆæµ‹è¯•ç»“æœ:', JSON.stringify(testResults, null, 2));
    console.log('ğŸ“Š æœ€ç»ˆæ€§èƒ½è¯„åˆ†:', performanceScore);
    console.log('ğŸ“Š æœ€ç»ˆæ€§èƒ½æŒ‡æ ‡:', JSON.stringify(finalMetrics, null, 2));
  </script>
</body>
</html>
