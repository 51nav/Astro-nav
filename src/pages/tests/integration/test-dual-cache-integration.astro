---
/**
 * åŒå±‚ç¼“å­˜é›†æˆæµ‹è¯•é¡µé¢
 * Week 3 - ä»»åŠ¡3.1é›†æˆéªŒè¯
 */

import { ConfigManager } from '../../../utils/ConfigManager';
import { LazyLoader } from '../../../utils/LazyLoader';
import { PreloadStrategy } from '../../../utils/PreloadStrategy';
import { LocalStorageCache } from '../../../utils/LocalStorageCache';

// æµ‹è¯•ç»“æœæ¥å£
interface TestResult {
  name: string;
  success: boolean;
  duration: number;
  details: any;
  error?: string;
}

async function runTest(name: string, testFn: () => Promise<any>): Promise<TestResult> {
  const startTime = performance.now();
  try {
    const result = await testFn();
    return {
      name,
      success: true,
      duration: performance.now() - startTime,
      details: result
    };
  } catch (error) {
    return {
      name,
      success: false,
      duration: performance.now() - startTime,
      details: {},
      error: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
    };
  }
}

// åˆå§‹åŒ–ç»„ä»¶
const configManager = new ConfigManager();
const lazyLoader = new LazyLoader(configManager);
const preloadStrategy = new PreloadStrategy(lazyLoader, configManager);

// æ‰§è¡Œé›†æˆæµ‹è¯•
const testResults: TestResult[] = [
  // æµ‹è¯•1: åŒå±‚ç¼“å­˜ç³»ç»Ÿåˆå§‹åŒ–
  await runTest('åŒå±‚ç¼“å­˜ç³»ç»Ÿåˆå§‹åŒ–', async () => {
    const cacheStats = lazyLoader.getCacheStats();
    
    return {
      memoryCache: {
        initialized: cacheStats.memoryCache !== undefined,
        size: cacheStats.memoryCache.cacheSize,
        maxSize: cacheStats.memoryCache.maxCacheSize
      },
      localStorage: {
        initialized: cacheStats.localStorage !== undefined,
        totalItems: cacheStats.localStorage.totalItems,
        totalSize: cacheStats.localStorage.totalSize,
        hitRate: cacheStats.localStorage.hitRate
      },
      dualCacheWorking: cacheStats.memoryCache !== undefined && cacheStats.localStorage !== undefined
    };
  }),

  // æµ‹è¯•2: é…ç½®åŠ è½½ä¸ç¼“å­˜
  await runTest('é…ç½®åŠ è½½ä¸ç¼“å­˜', async () => {
    // åŠ è½½é…ç½®
    const configResult = await configManager.loadConfig();
    
    if (!configResult.success) {
      throw new Error('é…ç½®åŠ è½½å¤±è´¥');
    }
    
    const categories = configManager.getAllCategoryIndexes();
    const cacheStatsBefore = lazyLoader.getCacheStats();
    
    return {
      configLoaded: configResult.success,
      categoryCount: categories.length,
      isOptimized: configResult.isOptimized,
      loadTime: configResult.loadTime,
      cacheStatsBefore: {
        memorySize: cacheStatsBefore.memoryCache.cacheSize,
        localStorageItems: cacheStatsBefore.localStorage.totalItems
      }
    };
  }),

  // æµ‹è¯•3: åˆ†ç±»æ•°æ®åŒå±‚ç¼“å­˜
  await runTest('åˆ†ç±»æ•°æ®åŒå±‚ç¼“å­˜', async () => {
    const configResult = await configManager.loadConfig();
    
    if (!configResult.success) {
      throw new Error('é…ç½®åŠ è½½å¤±è´¥');
    }
    
    const categories = configManager.getAllCategoryIndexes();
    if (categories.length === 0) {
      throw new Error('æ²¡æœ‰å¯ç”¨çš„åˆ†ç±»');
    }
    
    const testCategoryIndex = categories[0];
    
    // ç¬¬ä¸€æ¬¡åŠ è½½ (ä»ç½‘ç»œ)
    const firstLoad = await lazyLoader.loadCategory(testCategoryIndex);
    const statsAfterFirst = lazyLoader.getCacheStats();
    
    // ç¬¬äºŒæ¬¡åŠ è½½ (ä»å†…å­˜ç¼“å­˜)
    const secondLoad = await lazyLoader.loadCategory(testCategoryIndex);
    const statsAfterSecond = lazyLoader.getCacheStats();
    
    // æ¸…é™¤å†…å­˜ç¼“å­˜ï¼Œæ¨¡æ‹Ÿé¡µé¢åˆ·æ–°
    await lazyLoader.clearCache();
    
    // ç¬¬ä¸‰æ¬¡åŠ è½½ (ä»localStorage)
    const thirdLoad = await lazyLoader.loadCategory(testCategoryIndex);
    const statsAfterThird = lazyLoader.getCacheStats();
    
    return {
      firstLoad: {
        success: firstLoad.success,
        fromCache: firstLoad.fromCache,
        loadTime: firstLoad.loadTime
      },
      secondLoad: {
        success: secondLoad.success,
        fromCache: secondLoad.fromCache,
        loadTime: secondLoad.loadTime
      },
      thirdLoad: {
        success: thirdLoad.success,
        fromCache: thirdLoad.fromCache,
        loadTime: thirdLoad.loadTime,
        cacheSource: (thirdLoad as any).cacheSource
      },
      cacheProgression: {
        afterFirst: statsAfterFirst.memoryCache.cacheSize,
        afterSecond: statsAfterSecond.memoryCache.cacheSize,
        afterThird: statsAfterThird.memoryCache.cacheSize
      },
      dualCacheWorking: firstLoad.success && secondLoad.fromCache && thirdLoad.fromCache
    };
  }),

  // æµ‹è¯•4: é¢„åŠ è½½ä¸åŒå±‚ç¼“å­˜
  await runTest('é¢„åŠ è½½ä¸åŒå±‚ç¼“å­˜', async () => {
    const configResult = await configManager.loadConfig();
    
    if (!configResult.success) {
      throw new Error('é…ç½®åŠ è½½å¤±è´¥');
    }
    
    // æ¸…ç©ºç¼“å­˜
    await lazyLoader.clearCache();
    
    const statsBefore = lazyLoader.getCacheStats();
    
    // æ‰§è¡Œé¢„åŠ è½½
    await preloadStrategy.executePreload();
    
    const statsAfter = lazyLoader.getCacheStats();
    const preloadStats = preloadStrategy.getPreloadStats();
    
    return {
      preloadExecution: {
        totalPreloads: preloadStats.totalPreloads,
        successCount: preloadStats.successCount,
        failureCount: preloadStats.failureCount,
        successRate: preloadStats.successRate
      },
      cacheChanges: {
        memoryCacheBefore: statsBefore.memoryCache.cacheSize,
        memoryCacheAfter: statsAfter.memoryCache.cacheSize,
        localStorageBefore: statsBefore.localStorage.totalItems,
        localStorageAfter: statsAfter.localStorage.totalItems
      },
      preloadCacheWorking: statsAfter.memoryCache.cacheSize > statsBefore.memoryCache.cacheSize ||
                          statsAfter.localStorage.totalItems > statsBefore.localStorage.totalItems
    };
  }),

  // æµ‹è¯•5: ç¼“å­˜æ€§èƒ½å¯¹æ¯”
  await runTest('ç¼“å­˜æ€§èƒ½å¯¹æ¯”', async () => {
    const configResult = await configManager.loadConfig();
    
    if (!configResult.success) {
      throw new Error('é…ç½®åŠ è½½å¤±è´¥');
    }
    
    const categories = configManager.getAllCategoryIndexes();
    if (categories.length < 3) {
      throw new Error('åˆ†ç±»æ•°é‡ä¸è¶³');
    }
    
    const performanceResults = [];
    
    // æµ‹è¯•å‰3ä¸ªåˆ†ç±»çš„åŠ è½½æ€§èƒ½
    for (let i = 0; i < Math.min(3, categories.length); i++) {
      const categoryIndex = categories[i];
      
      // æ¸…é™¤è¯¥åˆ†ç±»çš„ç¼“å­˜
      await lazyLoader.clearCache();
      
      // ç½‘ç»œåŠ è½½
      const networkStart = performance.now();
      const networkResult = await lazyLoader.loadCategory(categoryIndex);
      const networkTime = performance.now() - networkStart;
      
      // å†…å­˜ç¼“å­˜åŠ è½½
      const memoryStart = performance.now();
      const memoryResult = await lazyLoader.loadCategory(categoryIndex);
      const memoryTime = performance.now() - memoryStart;
      
      // æ¸…é™¤å†…å­˜ç¼“å­˜ï¼Œä¿ç•™localStorage
      const tempStats = lazyLoader.getCacheStats();
      await lazyLoader.clearCache();
      
      // localStorageåŠ è½½
      const localStorageStart = performance.now();
      const localStorageResult = await lazyLoader.loadCategory(categoryIndex);
      const localStorageTime = performance.now() - localStorageStart;
      
      performanceResults.push({
        categoryIndex,
        networkTime,
        memoryTime,
        localStorageTime,
        speedup: {
          memoryVsNetwork: networkTime / memoryTime,
          localStorageVsNetwork: networkTime / localStorageTime
        }
      });
    }
    
    const avgSpeedup = performanceResults.reduce((acc, result) => ({
      memory: acc.memory + result.speedup.memoryVsNetwork,
      localStorage: acc.localStorage + result.speedup.localStorageVsNetwork
    }), { memory: 0, localStorage: 0 });
    
    avgSpeedup.memory /= performanceResults.length;
    avgSpeedup.localStorage /= performanceResults.length;
    
    return {
      performanceResults,
      averageSpeedup: avgSpeedup,
      performanceImprovement: avgSpeedup.memory > 2 && avgSpeedup.localStorage > 1.5
    };
  }),

  // æµ‹è¯•6: ç¼“å­˜å®¹é‡ç®¡ç†
  await runTest('ç¼“å­˜å®¹é‡ç®¡ç†', async () => {
    const configResult = await configManager.loadConfig();
    
    if (!configResult.success) {
      throw new Error('é…ç½®åŠ è½½å¤±è´¥');
    }
    
    const categories = configManager.getAllCategoryIndexes();
    
    // æ¸…ç©ºç¼“å­˜
    await lazyLoader.clearCache();
    
    const initialStats = lazyLoader.getCacheStats();
    
    // åŠ è½½å¤šä¸ªåˆ†ç±»ï¼Œæµ‹è¯•LRUæœºåˆ¶
    const loadResults = [];
    const maxCategoriesToLoad = Math.min(15, categories.length); // è¶…è¿‡å†…å­˜ç¼“å­˜é™åˆ¶
    
    for (let i = 0; i < maxCategoriesToLoad; i++) {
      const result = await lazyLoader.loadCategory(categories[i]);
      const stats = lazyLoader.getCacheStats();
      
      loadResults.push({
        categoryIndex: categories[i],
        success: result.success,
        memoryCacheSize: stats.memoryCache.cacheSize,
        localStorageItems: stats.localStorage.totalItems
      });
    }
    
    const finalStats = lazyLoader.getCacheStats();
    
    return {
      initialStats: {
        memorySize: initialStats.memoryCache.cacheSize,
        localStorageItems: initialStats.localStorage.totalItems
      },
      finalStats: {
        memorySize: finalStats.memoryCache.cacheSize,
        localStorageItems: finalStats.localStorage.totalItems,
        maxMemorySize: finalStats.memoryCache.maxCacheSize
      },
      loadResults,
      categoriesLoaded: maxCategoriesToLoad,
      lruWorking: finalStats.memoryCache.cacheSize <= finalStats.memoryCache.maxCacheSize,
      localStorageGrowth: finalStats.localStorage.totalItems > initialStats.localStorage.totalItems
    };
  }),

  // æµ‹è¯•7: ç¼“å­˜æ¸…ç†å’Œè¿‡æœŸ
  await runTest('ç¼“å­˜æ¸…ç†å’Œè¿‡æœŸ', async () => {
    const configResult = await configManager.loadConfig();
    
    if (!configResult.success) {
      throw new Error('é…ç½®åŠ è½½å¤±è´¥');
    }
    
    const categories = configManager.getAllCategoryIndexes();
    if (categories.length === 0) {
      throw new Error('æ²¡æœ‰å¯ç”¨çš„åˆ†ç±»');
    }
    
    // åŠ è½½ä¸€äº›åˆ†ç±»
    await lazyLoader.loadCategory(categories[0]);
    if (categories.length > 1) {
      await lazyLoader.loadCategory(categories[1]);
    }
    
    const statsBeforeCleanup = lazyLoader.getCacheStats();
    
    // æ‰§è¡Œæ¸…ç†
    const cleanedCount = await lazyLoader.cleanExpiredCache();
    
    const statsAfterCleanup = lazyLoader.getCacheStats();
    
    // æ¸…ç©ºæ‰€æœ‰ç¼“å­˜
    await lazyLoader.clearCache();
    
    const statsAfterClear = lazyLoader.getCacheStats();
    
    return {
      beforeCleanup: {
        memorySize: statsBeforeCleanup.memoryCache.cacheSize,
        localStorageItems: statsBeforeCleanup.localStorage.totalItems
      },
      afterCleanup: {
        memorySize: statsAfterCleanup.memoryCache.cacheSize,
        localStorageItems: statsAfterCleanup.localStorage.totalItems,
        cleanedCount
      },
      afterClear: {
        memorySize: statsAfterClear.memoryCache.cacheSize,
        localStorageItems: statsAfterClear.localStorage.totalItems
      },
      cleanupWorking: cleanedCount >= 0,
      clearWorking: statsAfterClear.memoryCache.cacheSize === 0
    };
  }),

  // æµ‹è¯•8: ç¼“å­˜ç»Ÿè®¡å’Œç›‘æ§
  await runTest('ç¼“å­˜ç»Ÿè®¡å’Œç›‘æ§', async () => {
    const configResult = await configManager.loadConfig();
    
    if (!configResult.success) {
      throw new Error('é…ç½®åŠ è½½å¤±è´¥');
    }
    
    const categories = configManager.getAllCategoryIndexes();
    
    // æ‰§è¡Œä¸€ç³»åˆ—æ“ä½œæ¥ç”Ÿæˆç»Ÿè®¡æ•°æ®
    const operations = [];
    
    for (let i = 0; i < Math.min(5, categories.length); i++) {
      const startTime = performance.now();
      const result = await lazyLoader.loadCategory(categories[i]);
      const endTime = performance.now();
      
      operations.push({
        categoryIndex: categories[i],
        success: result.success,
        fromCache: result.fromCache,
        loadTime: endTime - startTime
      });
      
      // é‡å¤åŠ è½½æµ‹è¯•ç¼“å­˜å‘½ä¸­
      const cacheStartTime = performance.now();
      const cacheResult = await lazyLoader.loadCategory(categories[i]);
      const cacheEndTime = performance.now();
      
      operations.push({
        categoryIndex: categories[i],
        success: cacheResult.success,
        fromCache: cacheResult.fromCache,
        loadTime: cacheEndTime - cacheStartTime,
        repeat: true
      });
    }
    
    const finalStats = lazyLoader.getCacheStats();
    
    return {
      operations,
      finalStats: {
        memoryCache: finalStats.memoryCache,
        localStorage: {
          totalItems: finalStats.localStorage.totalItems,
          totalSize: finalStats.localStorage.totalSize,
          hitRate: finalStats.localStorage.hitRate,
          averageSize: finalStats.localStorage.averageSize
        }
      },
      performance: {
        networkLoads: operations.filter(op => !op.fromCache && !op.repeat).length,
        cacheHits: operations.filter(op => op.fromCache).length,
        avgNetworkTime: operations.filter(op => !op.fromCache && !op.repeat)
          .reduce((sum, op) => sum + op.loadTime, 0) / 
          operations.filter(op => !op.fromCache && !op.repeat).length,
        avgCacheTime: operations.filter(op => op.fromCache)
          .reduce((sum, op) => sum + op.loadTime, 0) / 
          operations.filter(op => op.fromCache).length
      },
      monitoringWorking: finalStats.localStorage.hitRate >= 0 && finalStats.memoryCache.cacheSize >= 0
    };
  })
];

const successCount = testResults.filter(r => r.success).length;
const totalTests = testResults.length;
const successRate = (successCount / totalTests * 100).toFixed(1);

// è·å–æœ€ç»ˆç³»ç»ŸçŠ¶æ€
const finalCacheStats = lazyLoader.getCacheStats();
---

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>åŒå±‚ç¼“å­˜é›†æˆæµ‹è¯•</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    
    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
      margin-bottom: 30px;
      text-align: center;
    }
    
    .cache-architecture {
      background: white;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin-bottom: 30px;
    }
    
    .architecture-diagram {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      margin-top: 20px;
    }
    
    .cache-layer {
      padding: 20px;
      border-radius: 8px;
      border: 2px solid #e5e7eb;
      text-align: center;
    }
    
    .cache-layer.memory {
      background: #dbeafe;
      border-color: #3b82f6;
    }
    
    .cache-layer.storage {
      background: #d1fae5;
      border-color: #10b981;
    }
    
    .layer-title {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 10px;
    }
    
    .layer-stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 15px;
    }
    
    .stat-item {
      background: rgba(255, 255, 255, 0.7);
      padding: 10px;
      border-radius: 4px;
      font-size: 14px;
    }
    
    .stat-value {
      font-weight: bold;
      color: #1f2937;
    }
    
    .summary {
      background: white;
      padding: 25px;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin-bottom: 30px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
    }
    
    .summary-item {
      text-align: center;
      padding: 20px;
      border-radius: 8px;
      background: #f8f9fa;
    }
    
    .summary-item.success {
      background: #d4edda;
      color: #155724;
    }
    
    .summary-item.warning {
      background: #fff3cd;
      color: #856404;
    }
    
    .summary-item .value {
      font-size: 32px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .summary-item .label {
      font-size: 14px;
      opacity: 0.8;
    }
    
    .test-results {
      display: grid;
      gap: 20px;
    }
    
    .test-card {
      background: white;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      overflow: hidden;
    }
    
    .test-header {
      padding: 20px;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .test-header.success {
      background: #d4edda;
      color: #155724;
    }
    
    .test-header.error {
      background: #f8d7da;
      color: #721c24;
    }
    
    .test-name {
      font-size: 18px;
      font-weight: 600;
    }
    
    .test-duration {
      font-size: 14px;
      opacity: 0.8;
    }
    
    .test-content {
      padding: 20px;
    }
    
    .test-details {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 15px;
      margin-top: 15px;
    }
    
    .test-details pre {
      margin: 0;
      font-size: 14px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    
    .error-message {
      background: #f8d7da;
      color: #721c24;
      padding: 15px;
      border-radius: 8px;
      margin-top: 15px;
      border-left: 4px solid #dc3545;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>ğŸ’¾ åŒå±‚ç¼“å­˜é›†æˆæµ‹è¯•</h1>
    <div class="subtitle">Week 3 - ä»»åŠ¡3.1é›†æˆéªŒè¯ | æµ‹è¯•æ—¶é—´: {new Date().toLocaleString()}</div>
  </div>

  <!-- ç¼“å­˜æ¶æ„å›¾ -->
  <div class="cache-architecture">
    <h2>ğŸ—ï¸ åŒå±‚ç¼“å­˜æ¶æ„</h2>
    <div class="architecture-diagram">
      <div class="cache-layer memory">
        <div class="layer-title">ğŸ§  å†…å­˜ç¼“å­˜ (L1)</div>
        <div class="layer-description">LRUç®—æ³•ï¼Œå¿«é€Ÿè®¿é—®</div>
        <div class="layer-stats">
          <div class="stat-item">
            <div class="stat-value">{finalCacheStats.memoryCache.cacheSize}</div>
            <div>å½“å‰é¡¹æ•°</div>
          </div>
          <div class="stat-item">
            <div class="stat-value">{finalCacheStats.memoryCache.maxCacheSize}</div>
            <div>æœ€å¤§å®¹é‡</div>
          </div>
        </div>
      </div>
      
      <div class="cache-layer storage">
        <div class="layer-title">ğŸ’¿ æœ¬åœ°å­˜å‚¨ç¼“å­˜ (L2)</div>
        <div class="layer-description">æŒä¹…åŒ–å­˜å‚¨ï¼Œå‹ç¼©ä¼˜åŒ–</div>
        <div class="layer-stats">
          <div class="stat-item">
            <div class="stat-value">{finalCacheStats.localStorage.totalItems}</div>
            <div>å­˜å‚¨é¡¹æ•°</div>
          </div>
          <div class="stat-item">
            <div class="stat-value">{(finalCacheStats.localStorage.totalSize / 1024).toFixed(1)}KB</div>
            <div>å­˜å‚¨å¤§å°</div>
          </div>
          <div class="stat-item">
            <div class="stat-value">{finalCacheStats.localStorage.hitRate.toFixed(1)}%</div>
            <div>å‘½ä¸­ç‡</div>
          </div>
          <div class="stat-item">
            <div class="stat-value">{(finalCacheStats.localStorage.compressionRatio * 100).toFixed(1)}%</div>
            <div>å‹ç¼©ç‡</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- æµ‹è¯•ç»“æœ -->
  <div class="summary">
    <div class={`summary-item ${successRate === '100.0' ? 'success' : 'warning'}`}>
      <div class="value">{successRate}%</div>
      <div class="label">é›†æˆæµ‹è¯•é€šè¿‡ç‡</div>
    </div>
    <div class="summary-item">
      <div class="value">{successCount}</div>
      <div class="label">é€šè¿‡æµ‹è¯•</div>
    </div>
    <div class="summary-item">
      <div class="value">{totalTests - successCount}</div>
      <div class="label">å¤±è´¥æµ‹è¯•</div>
    </div>
    <div class={`summary-item ${finalCacheStats.localStorage.hitRate >= 50 ? 'success' : 'warning'}`}>
      <div class="value">{finalCacheStats.localStorage.hitRate.toFixed(1)}%</div>
      <div class="label">ç¼“å­˜å‘½ä¸­ç‡</div>
    </div>
  </div>

  <div class="test-results">
    {testResults.map((result, index) => (
      <div class="test-card">
        <div class={`test-header ${result.success ? 'success' : 'error'}`}>
          <div class="test-name">
            <span>{result.success ? 'âœ…' : 'âŒ'}</span>
            é›†æˆæµ‹è¯• {index + 1}: {result.name}
          </div>
          <div class="test-duration">{result.duration.toFixed(2)}ms</div>
        </div>
        <div class="test-content">
          <div class="test-details">
            <strong>æµ‹è¯•è¯¦æƒ…:</strong>
            <pre>{JSON.stringify(result.details, null, 2)}</pre>
          </div>
          {result.error && (
            <div class="error-message">
              <strong>é”™è¯¯ä¿¡æ¯:</strong> {result.error}
            </div>
          )}
        </div>
      </div>
    ))}
  </div>

  <script define:vars={{ testResults, finalCacheStats }}>
    console.log('ğŸ’¾ åŒå±‚ç¼“å­˜é›†æˆæµ‹è¯•é¡µé¢å·²åŠ è½½');
    console.log('ğŸ“Š é›†æˆæµ‹è¯•ç»“æœ:', JSON.stringify(testResults, null, 2));
    console.log('ğŸ“Š æœ€ç»ˆç¼“å­˜çŠ¶æ€:', JSON.stringify(finalCacheStats, null, 2));
  </script>
</body>
</html>
