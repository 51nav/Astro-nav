---
/**
 * æ€§èƒ½ç›‘æ§é¢æ¿ç»„ä»¶
 * Week 3 - ä»»åŠ¡2.2
 */

export interface Props {
  /** æ˜¯å¦æ˜¾ç¤ºæ€§èƒ½é¢æ¿ */
  visible?: boolean;
  /** é¢æ¿ä½ç½® */
  position?: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left';
  /** æ˜¯å¦å¯æŠ˜å  */
  collapsible?: boolean;
  /** é»˜è®¤æ˜¯å¦æŠ˜å  */
  defaultCollapsed?: boolean;
  /** æ›´æ–°é—´éš” (ms) */
  updateInterval?: number;
  /** è‡ªå®šä¹‰CSSç±» */
  className?: string;
}

const {
  visible = true,
  position = 'top-right',
  collapsible = true,
  defaultCollapsed = false,
  updateInterval = 5000,
  className = ''
} = Astro.props;

// å¦‚æœä¸æ˜¾ç¤ºï¼Œç›´æ¥è¿”å›
if (!visible) {
  return null;
}

// ç”ŸæˆCSSç±»å
const positionClass = `monitor-${position}`;
const combinedClass = ['performance-monitor', positionClass, className].filter(Boolean).join(' ');
---

<div class={combinedClass} id="performance-monitor">
  <!-- é¢æ¿å¤´éƒ¨ -->
  <div class="monitor-header">
    <div class="monitor-title">
      <span class="monitor-icon">ğŸ“Š</span>
      <span class="monitor-text">æ€§èƒ½ç›‘æ§</span>
      <span class="monitor-score" id="performance-score">--</span>
    </div>
    {collapsible && (
      <button class="monitor-toggle" id="monitor-toggle" aria-label="æŠ˜å /å±•å¼€æ€§èƒ½é¢æ¿">
        <span class="toggle-icon">â–¼</span>
      </button>
    )}
  </div>

  <!-- é¢æ¿å†…å®¹ -->
  <div class="monitor-content" id="monitor-content">
    <!-- æ ¸å¿ƒæŒ‡æ ‡ -->
    <div class="metrics-section">
      <h4 class="section-title">æ ¸å¿ƒæŒ‡æ ‡</h4>
      <div class="metrics-grid">
        <div class="metric-item">
          <div class="metric-label">é…ç½®åŠ è½½</div>
          <div class="metric-value" id="config-load-time">--ms</div>
        </div>
        <div class="metric-item">
          <div class="metric-label">åˆ†ç±»åŠ è½½</div>
          <div class="metric-value" id="category-load-time">--ms</div>
        </div>
        <div class="metric-item">
          <div class="metric-label">ç¼“å­˜å‘½ä¸­ç‡</div>
          <div class="metric-value" id="cache-hit-rate">--%</div>
        </div>
        <div class="metric-item">
          <div class="metric-label">å†…å­˜ä½¿ç”¨</div>
          <div class="metric-value" id="memory-usage">--MB</div>
        </div>
      </div>
    </div>

    <!-- å®æ—¶ç»Ÿè®¡ -->
    <div class="stats-section">
      <h4 class="section-title">å®æ—¶ç»Ÿè®¡</h4>
      <div class="stats-list">
        <div class="stat-item">
          <span class="stat-label">ç½‘ç»œè¯·æ±‚:</span>
          <span class="stat-value" id="network-requests">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">ç”¨æˆ·äº¤äº’:</span>
          <span class="stat-value" id="user-interactions">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">é¢„åŠ è½½æ¬¡æ•°:</span>
          <span class="stat-value" id="preload-count">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">ç¼“å­˜å¤§å°:</span>
          <span class="stat-value" id="cache-size">0</span>
        </div>
      </div>
    </div>

    <!-- æ€§èƒ½è­¦å‘Š -->
    <div class="alerts-section">
      <h4 class="section-title">æ€§èƒ½è­¦å‘Š</h4>
      <div class="alerts-container" id="alerts-container">
        <div class="no-alerts">æš‚æ— è­¦å‘Š</div>
      </div>
    </div>

    <!-- ä¼˜åŒ–å»ºè®® -->
    <div class="recommendations-section">
      <h4 class="section-title">ä¼˜åŒ–å»ºè®®</h4>
      <div class="recommendations-container" id="recommendations-container">
        <div class="no-recommendations">æš‚æ— å»ºè®®</div>
      </div>
    </div>

    <!-- æ“ä½œæŒ‰é’® -->
    <div class="actions-section">
      <button class="action-btn" id="refresh-btn">åˆ·æ–°æ•°æ®</button>
      <button class="action-btn" id="export-btn">å¯¼å‡ºæŠ¥å‘Š</button>
      <button class="action-btn" id="reset-btn">é‡ç½®ç»Ÿè®¡</button>
    </div>
  </div>
</div>

<style>
  /* åŸºç¡€æ ·å¼ */
  .performance-monitor {
    position: fixed;
    z-index: 9999;
    width: 320px;
    max-height: 80vh;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    font-size: 14px;
    overflow: hidden;
    transition: all 0.3s ease;
  }

  /* ä½ç½®æ ·å¼ */
  .monitor-top-right {
    top: 20px;
    right: 20px;
  }

  .monitor-top-left {
    top: 20px;
    left: 20px;
  }

  .monitor-bottom-right {
    bottom: 20px;
    right: 20px;
  }

  .monitor-bottom-left {
    bottom: 20px;
    left: 20px;
  }

  /* å¤´éƒ¨æ ·å¼ */
  .monitor-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    cursor: move;
  }

  .monitor-title {
    display: flex;
    align-items: center;
    gap: 8px;
    font-weight: 600;
  }

  .monitor-icon {
    font-size: 16px;
  }

  .monitor-score {
    background: rgba(255, 255, 255, 0.2);
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: bold;
  }

  .monitor-toggle {
    background: none;
    border: none;
    color: white;
    cursor: pointer;
    padding: 4px;
    border-radius: 4px;
    transition: background-color 0.2s ease;
  }

  .monitor-toggle:hover {
    background: rgba(255, 255, 255, 0.1);
  }

  .toggle-icon {
    display: inline-block;
    transition: transform 0.3s ease;
  }

  .monitor-toggle.collapsed .toggle-icon {
    transform: rotate(-90deg);
  }

  /* å†…å®¹æ ·å¼ */
  .monitor-content {
    max-height: calc(80vh - 60px);
    overflow-y: auto;
    transition: max-height 0.3s ease;
  }

  .monitor-content.collapsed {
    max-height: 0;
    overflow: hidden;
  }

  /* åŒºåŸŸæ ·å¼ */
  .metrics-section,
  .stats-section,
  .alerts-section,
  .recommendations-section,
  .actions-section {
    padding: 16px;
    border-bottom: 1px solid #f3f4f6;
  }

  .actions-section {
    border-bottom: none;
  }

  .section-title {
    margin: 0 0 12px 0;
    font-size: 13px;
    font-weight: 600;
    color: #374151;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  /* æŒ‡æ ‡ç½‘æ ¼ */
  .metrics-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
  }

  .metric-item {
    text-align: center;
    padding: 12px;
    background: #f8fafc;
    border-radius: 8px;
    border: 1px solid #e2e8f0;
  }

  .metric-label {
    font-size: 11px;
    color: #64748b;
    margin-bottom: 4px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .metric-value {
    font-size: 16px;
    font-weight: bold;
    color: #1e293b;
  }

  .metric-value.good {
    color: #059669;
  }

  .metric-value.warning {
    color: #d97706;
  }

  .metric-value.error {
    color: #dc2626;
  }

  /* ç»Ÿè®¡åˆ—è¡¨ */
  .stats-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .stat-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 12px;
    background: #f8fafc;
    border-radius: 6px;
  }

  .stat-label {
    color: #64748b;
    font-size: 12px;
  }

  .stat-value {
    font-weight: 600;
    color: #1e293b;
  }

  /* è­¦å‘Šæ ·å¼ */
  .alerts-container,
  .recommendations-container {
    max-height: 120px;
    overflow-y: auto;
  }

  .alert-item {
    padding: 8px 12px;
    margin-bottom: 8px;
    border-radius: 6px;
    font-size: 12px;
    border-left: 4px solid;
  }

  .alert-item.warning {
    background: #fef3c7;
    border-left-color: #f59e0b;
    color: #92400e;
  }

  .alert-item.error {
    background: #fee2e2;
    border-left-color: #ef4444;
    color: #991b1b;
  }

  .alert-item.info {
    background: #dbeafe;
    border-left-color: #3b82f6;
    color: #1e40af;
  }

  /* å»ºè®®æ ·å¼ */
  .recommendation-item {
    padding: 10px 12px;
    margin-bottom: 8px;
    background: #f0fdf4;
    border: 1px solid #bbf7d0;
    border-radius: 6px;
    font-size: 12px;
  }

  .recommendation-title {
    font-weight: 600;
    color: #166534;
    margin-bottom: 4px;
  }

  .recommendation-desc {
    color: #15803d;
    line-height: 1.4;
  }

  .recommendation-impact {
    display: inline-block;
    padding: 2px 6px;
    border-radius: 10px;
    font-size: 10px;
    font-weight: 600;
    margin-top: 4px;
  }

  .recommendation-impact.high {
    background: #fee2e2;
    color: #991b1b;
  }

  .recommendation-impact.medium {
    background: #fef3c7;
    color: #92400e;
  }

  .recommendation-impact.low {
    background: #dbeafe;
    color: #1e40af;
  }

  /* æ— æ•°æ®æ ·å¼ */
  .no-alerts,
  .no-recommendations {
    text-align: center;
    color: #9ca3af;
    font-size: 12px;
    padding: 20px;
  }

  /* æ“ä½œæŒ‰é’® */
  .actions-section {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }

  .action-btn {
    flex: 1;
    padding: 8px 12px;
    border: 1px solid #d1d5db;
    background: white;
    color: #374151;
    border-radius: 6px;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .action-btn:hover {
    background: #f3f4f6;
    border-color: #9ca3af;
  }

  .action-btn:active {
    transform: translateY(1px);
  }

  /* æ»šåŠ¨æ¡æ ·å¼ */
  .monitor-content::-webkit-scrollbar,
  .alerts-container::-webkit-scrollbar,
  .recommendations-container::-webkit-scrollbar {
    width: 6px;
  }

  .monitor-content::-webkit-scrollbar-track,
  .alerts-container::-webkit-scrollbar-track,
  .recommendations-container::-webkit-scrollbar-track {
    background: #f1f5f9;
  }

  .monitor-content::-webkit-scrollbar-thumb,
  .alerts-container::-webkit-scrollbar-thumb,
  .recommendations-container::-webkit-scrollbar-thumb {
    background: #cbd5e1;
    border-radius: 3px;
  }

  /* å“åº”å¼è®¾è®¡ */
  @media (max-width: 768px) {
    .performance-monitor {
      width: 280px;
      max-height: 70vh;
    }

    .metrics-grid {
      grid-template-columns: 1fr;
    }

    .actions-section {
      flex-direction: column;
    }

    .action-btn {
      flex: none;
    }
  }

  /* æ·±è‰²æ¨¡å¼æ”¯æŒ */
  @media (prefers-color-scheme: dark) {
    .performance-monitor {
      background: rgba(31, 41, 55, 0.95);
      border-color: #4b5563;
      color: #f9fafb;
    }

    .section-title {
      color: #d1d5db;
    }

    .metric-item,
    .stat-item {
      background: #374151;
      border-color: #4b5563;
    }

    .metric-value,
    .stat-value {
      color: #f9fafb;
    }

    .stat-label {
      color: #9ca3af;
    }

    .action-btn {
      background: #374151;
      border-color: #4b5563;
      color: #f9fafb;
    }

    .action-btn:hover {
      background: #4b5563;
    }
  }

  /* åŠ¨ç”»æ•ˆæœ */
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }

  .metric-value.updating {
    animation: pulse 1s ease-in-out;
  }

  /* æ‹–æ‹½æ ·å¼ */
  .performance-monitor.dragging {
    transform: rotate(2deg);
    box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
  }
</style>

<script define:vars={{ updateInterval, defaultCollapsed }}>
  console.log('ğŸ“Š PerformanceMonitorç»„ä»¶å·²åŠ è½½');

  // æ€§èƒ½ç›‘æ§çŠ¶æ€
  let isCollapsed = defaultCollapsed;
  let isDragging = false;
  let dragOffset = { x: 0, y: 0 };

  // DOMå…ƒç´ 
  const monitor = document.getElementById('performance-monitor');
  const toggle = document.getElementById('monitor-toggle');
  const content = document.getElementById('monitor-content');
  const refreshBtn = document.getElementById('refresh-btn');
  const exportBtn = document.getElementById('export-btn');
  const resetBtn = document.getElementById('reset-btn');

  // åˆå§‹åŒ–
  function initialize() {
    if (isCollapsed) {
      toggleCollapse();
    }
    
    // ç»‘å®šäº‹ä»¶
    if (toggle) {
      toggle.addEventListener('click', toggleCollapse);
    }
    
    if (refreshBtn) {
      refreshBtn.addEventListener('click', refreshData);
    }
    
    if (exportBtn) {
      exportBtn.addEventListener('click', exportReport);
    }
    
    if (resetBtn) {
      resetBtn.addEventListener('click', resetStats);
    }
    
    // æ‹–æ‹½åŠŸèƒ½
    if (monitor) {
      const header = monitor.querySelector('.monitor-header');
      if (header) {
        header.addEventListener('mousedown', startDrag);
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', endDrag);
      }
    }
    
    // å¼€å§‹å®šæœŸæ›´æ–°
    startUpdating();
  }

  // æŠ˜å /å±•å¼€
  function toggleCollapse() {
    isCollapsed = !isCollapsed;
    
    if (content) {
      content.classList.toggle('collapsed', isCollapsed);
    }
    
    if (toggle) {
      toggle.classList.toggle('collapsed', isCollapsed);
    }
  }

  // å¼€å§‹æ‹–æ‹½
  function startDrag(e) {
    isDragging = true;
    const rect = monitor.getBoundingClientRect();
    dragOffset.x = e.clientX - rect.left;
    dragOffset.y = e.clientY - rect.top;
    monitor.classList.add('dragging');
    e.preventDefault();
  }

  // æ‹–æ‹½ä¸­
  function drag(e) {
    if (!isDragging) return;
    
    const x = e.clientX - dragOffset.x;
    const y = e.clientY - dragOffset.y;
    
    monitor.style.left = `${x}px`;
    monitor.style.top = `${y}px`;
    monitor.style.right = 'auto';
    monitor.style.bottom = 'auto';
  }

  // ç»“æŸæ‹–æ‹½
  function endDrag() {
    if (isDragging) {
      isDragging = false;
      monitor.classList.remove('dragging');
    }
  }

  // åˆ·æ–°æ•°æ®
  function refreshData() {
    updateDisplay();
    console.log('ğŸ“Š æ€§èƒ½æ•°æ®å·²åˆ·æ–°');
  }

  // å¯¼å‡ºæŠ¥å‘Š
  function exportReport() {
    // æ¨¡æ‹Ÿå¯¼å‡ºåŠŸèƒ½
    const report = {
      timestamp: new Date().toISOString(),
      metrics: 'Performance metrics data...',
      alerts: 'Performance alerts data...',
      recommendations: 'Performance recommendations...'
    };
    
    const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `performance-report-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
    
    console.log('ğŸ“Š æ€§èƒ½æŠ¥å‘Šå·²å¯¼å‡º');
  }

  // é‡ç½®ç»Ÿè®¡
  function resetStats() {
    if (confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰æ€§èƒ½ç»Ÿè®¡æ•°æ®å—ï¼Ÿ')) {
      // é‡ç½®æ˜¾ç¤º
      updateDisplay({
        score: 100,
        configLoadTime: 0,
        categoryLoadTime: 0,
        cacheHitRate: 0,
        memoryUsage: 0,
        networkRequests: 0,
        userInteractions: 0,
        preloadCount: 0,
        cacheSize: 0
      });
      
      console.log('ğŸ“Š æ€§èƒ½ç»Ÿè®¡å·²é‡ç½®');
    }
  }

  // æ›´æ–°æ˜¾ç¤º
  function updateDisplay(data) {
    // æ¨¡æ‹Ÿæ€§èƒ½æ•°æ®
    const mockData = data || {
      score: Math.floor(Math.random() * 30) + 70,
      configLoadTime: Math.floor(Math.random() * 500) + 100,
      categoryLoadTime: Math.floor(Math.random() * 300) + 50,
      cacheHitRate: Math.floor(Math.random() * 30) + 70,
      memoryUsage: (Math.random() * 20 + 10).toFixed(1),
      networkRequests: Math.floor(Math.random() * 50) + 10,
      userInteractions: Math.floor(Math.random() * 20) + 5,
      preloadCount: Math.floor(Math.random() * 10) + 2,
      cacheSize: Math.floor(Math.random() * 8) + 2
    };

    // æ›´æ–°æ€§èƒ½è¯„åˆ†
    const scoreElement = document.getElementById('performance-score');
    if (scoreElement) {
      scoreElement.textContent = `${mockData.score}åˆ†`;
      scoreElement.className = `monitor-score ${getScoreClass(mockData.score)}`;
    }

    // æ›´æ–°æ ¸å¿ƒæŒ‡æ ‡
    updateMetricValue('config-load-time', `${mockData.configLoadTime}ms`, mockData.configLoadTime);
    updateMetricValue('category-load-time', `${mockData.categoryLoadTime}ms`, mockData.categoryLoadTime);
    updateMetricValue('cache-hit-rate', `${mockData.cacheHitRate}%`, mockData.cacheHitRate);
    updateMetricValue('memory-usage', `${mockData.memoryUsage}MB`, parseFloat(mockData.memoryUsage));

    // æ›´æ–°ç»Ÿè®¡æ•°æ®
    updateStatValue('network-requests', mockData.networkRequests);
    updateStatValue('user-interactions', mockData.userInteractions);
    updateStatValue('preload-count', mockData.preloadCount);
    updateStatValue('cache-size', mockData.cacheSize);

    // æ›´æ–°è­¦å‘Šå’Œå»ºè®®
    updateAlerts(mockData);
    updateRecommendations(mockData);
  }

  // æ›´æ–°æŒ‡æ ‡å€¼
  function updateMetricValue(id, value, numericValue) {
    const element = document.getElementById(id);
    if (element) {
      element.textContent = value;
      element.className = `metric-value ${getValueClass(id, numericValue)} updating`;
      
      // ç§»é™¤åŠ¨ç”»ç±»
      setTimeout(() => {
        element.classList.remove('updating');
      }, 1000);
    }
  }

  // æ›´æ–°ç»Ÿè®¡å€¼
  function updateStatValue(id, value) {
    const element = document.getElementById(id);
    if (element) {
      element.textContent = value;
    }
  }

  // è·å–è¯„åˆ†æ ·å¼ç±»
  function getScoreClass(score) {
    if (score >= 80) return 'good';
    if (score >= 60) return 'warning';
    return 'error';
  }

  // è·å–å€¼æ ·å¼ç±»
  function getValueClass(id, value) {
    const thresholds = {
      'config-load-time': { good: 500, warning: 1000 },
      'category-load-time': { good: 100, warning: 300 },
      'cache-hit-rate': { good: 80, warning: 60 },
      'memory-usage': { good: 30, warning: 50 }
    };

    const threshold = thresholds[id];
    if (!threshold) return '';

    if (id === 'cache-hit-rate') {
      // ç¼“å­˜å‘½ä¸­ç‡è¶Šé«˜è¶Šå¥½
      if (value >= threshold.good) return 'good';
      if (value >= threshold.warning) return 'warning';
      return 'error';
    } else {
      // å…¶ä»–æŒ‡æ ‡è¶Šä½è¶Šå¥½
      if (value <= threshold.good) return 'good';
      if (value <= threshold.warning) return 'warning';
      return 'error';
    }
  }

  // æ›´æ–°è­¦å‘Š
  function updateAlerts(data) {
    const container = document.getElementById('alerts-container');
    if (!container) return;

    const alerts = [];
    
    if (data.configLoadTime > 800) {
      alerts.push({
        type: 'warning',
        message: `é…ç½®åŠ è½½æ—¶é—´è¿‡é•¿: ${data.configLoadTime}ms`
      });
    }
    
    if (data.cacheHitRate < 70) {
      alerts.push({
        type: 'error',
        message: `ç¼“å­˜å‘½ä¸­ç‡è¿‡ä½: ${data.cacheHitRate}%`
      });
    }
    
    if (parseFloat(data.memoryUsage) > 40) {
      alerts.push({
        type: 'warning',
        message: `å†…å­˜ä½¿ç”¨è¿‡é«˜: ${data.memoryUsage}MB`
      });
    }

    if (alerts.length === 0) {
      container.innerHTML = '<div class="no-alerts">æš‚æ— è­¦å‘Š</div>';
    } else {
      container.innerHTML = alerts.map(alert => 
        `<div class="alert-item ${alert.type}">${alert.message}</div>`
      ).join('');
    }
  }

  // æ›´æ–°å»ºè®®
  function updateRecommendations(data) {
    const container = document.getElementById('recommendations-container');
    if (!container) return;

    const recommendations = [];
    
    if (data.cacheHitRate < 80) {
      recommendations.push({
        title: 'æé«˜ç¼“å­˜å‘½ä¸­ç‡',
        description: 'å»ºè®®å¢åŠ é¢„åŠ è½½ç­–ç•¥æˆ–è°ƒæ•´ç¼“å­˜å¤§å°',
        impact: 'high'
      });
    }
    
    if (data.categoryLoadTime > 200) {
      recommendations.push({
        title: 'ä¼˜åŒ–åŠ è½½æ€§èƒ½',
        description: 'å»ºè®®å¯ç”¨æ›´ç§¯æçš„é¢„åŠ è½½ç­–ç•¥',
        impact: 'medium'
      });
    }

    if (recommendations.length === 0) {
      container.innerHTML = '<div class="no-recommendations">æš‚æ— å»ºè®®</div>';
    } else {
      container.innerHTML = recommendations.map(rec => 
        `<div class="recommendation-item">
          <div class="recommendation-title">${rec.title}</div>
          <div class="recommendation-desc">${rec.description}</div>
          <span class="recommendation-impact ${rec.impact}">${rec.impact}</span>
        </div>`
      ).join('');
    }
  }

  // å¼€å§‹å®šæœŸæ›´æ–°
  function startUpdating() {
    updateDisplay(); // ç«‹å³æ›´æ–°ä¸€æ¬¡
    
    setInterval(() => {
      if (!isCollapsed) {
        updateDisplay();
      }
    }, updateInterval);
  }

  // åˆå§‹åŒ–ç»„ä»¶
  initialize();
</script>
